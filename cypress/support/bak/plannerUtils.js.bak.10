/**
 * Planner Test Utilities - Pure Logic Functions
 * 
 * Contains data extraction and calculation utilities for planner tests.
 * User actions and verifications are handled by Cypress commands.
 */

// Test timing and element constants
const PLANNER_CONSTANTS = {
  SELECTION_WAIT: 250,
  CALCULATOR_WAIT: 1000,
  TEAM_ACTION_WAIT: 500,
  FIRST_TEAM_MEMBER_COLUMN: 10,
  PRICE_COLUMN: 5,
  MAX_TEAM_MEMBERS: 20,
};

/**
 * Extract price from table row
 * Handles both "Free" courses and numeric prices
 */
const extractPriceFromRow = (rowIndex) => {
  return cy
    .get(`#table-row-${rowIndex}`)
    .find(`[aria-colindex="${PLANNER_CONSTANTS.PRICE_COLUMN}"]`)
    .invoke("text")
    .then((priceText) => {
      const cleanText = priceText.trim();

      if (cleanText === "Free" || cleanText === "") {
        return cy.then(() => 0);
      }

      const numericPrice = parseFloat(cleanText.replace(/[^0-9.]/g, ""));
      const finalPrice = isNaN(numericPrice) ? 0 : numericPrice;
      return cy.then(() => finalPrice);
    });
};

/**
 * Count team members using multiple detection methods
 * Primary: team-member-header class
 * Fallbacks: selection columns, name matching
 */
const getTeamMemberCount = () => {
  return cy.get('#monotable').then(() => {
    
    return cy.log('ðŸ” Counting team members').then(() => {
      
      // PRIMARY: Count team-member-header elements
      return cy.get('.team-member-header').then(($headers) => {
        const headerCount = $headers.length;
        
        if (headerCount > 0) {
          return cy.log(`ðŸ“Š Found ${headerCount} team member headers`).then(() => headerCount);
        } else {
          // FALLBACK: Count selection columns in first data row
          return cy.get('[id^="table-row-1"]').first().then(($row) => {
            if ($row.length > 0) {
              const selectionButtons = $row.find('[role="button"], .plan-cell-selected, .plan-cell-unselected');
              const selectionCount = selectionButtons.length;
              
              if (selectionCount > 0) {
                return cy.log(`ðŸ“Š Fallback: Found ${selectionCount} selection columns`).then(() => selectionCount);
              }
            }
            
            // FINAL FALLBACK: Count by name matching
            return cy.get('#monotable').then(($table) => {
              const tableText = $table.text();
              let nameCount = 0;
              if (tableText.includes("Richard Hendricks")) nameCount++;
              for (let i = 2; i <= 10; i++) {
                if (tableText.includes(`Team Member ${i}`)) nameCount++;
              }
              
              const finalCount = Math.max(nameCount, 1);
              return cy.log(`ðŸ“Š Final fallback: ${finalCount} team members`).then(() => finalCount);
            });
          });
        }
      });
    });
  });
};

/**
 * Calculate team member column index by name
 * Used for targeting specific team member columns in the table
 */
const getTeamMemberColumnIndex = (memberName) => {
  if (memberName === "Richard Hendricks") {
    return cy.then(() => PLANNER_CONSTANTS.FIRST_TEAM_MEMBER_COLUMN);
  }
  
  const match = memberName.match(/Team Member (\d+)/);
  if (match) {
    const memberNumber = parseInt(match[1]);
    const columnIndex = PLANNER_CONSTANTS.FIRST_TEAM_MEMBER_COLUMN + memberNumber - 1;
    return cy.then(() => columnIndex);
  }
  
  return cy.then(() => PLANNER_CONSTANTS.FIRST_TEAM_MEMBER_COLUMN);
};

/**
 * Generate random course selections for a team member
 * Returns array of unique row indices between 1 and poolSize
 */
const generateRandomSelections = (poolSize, minSelections, maxSelections) => {
  const selectionCount = Math.floor(Math.random() * (maxSelections - minSelections + 1)) + minSelections;
  const selections = [];
  
  while (selections.length < selectionCount) {
    const randomRow = Math.floor(Math.random() * poolSize) + 1;
    if (!selections.includes(randomRow)) {
      selections.push(randomRow);
    }
  }
  
  return selections.sort((a, b) => a - b);
};

/**
 * Calculate expected total for given selection arrays
 * Takes array of arrays (one per team member) of row indices
 */
const calculateExpectedTotal = (allMemberSelections) => {
  return cy.wrap(null).then(() => {
    let total = 0;
    let chain = cy.wrap(total);
    
    allMemberSelections.forEach((memberSelections) => {
      memberSelections.forEach((rowIndex) => {
        chain = chain.then((currentTotal) => {
          return extractPriceFromRow(rowIndex).then((price) => {
            return currentTotal + price;
          });
        });
      });
    });
    
    return chain;
  });
};

/**
 * Generate a realistic training plan with random selections per member
 * Returns object with member selections and expected totals
 */
const generateTrainingPlan = (teamCount, coursePoolSize, minSelections, maxSelections) => {
  const plan = {
    memberSelections: [],
    totalSelections: 0,
  };
  
  for (let i = 0; i < teamCount; i++) {
    const selections = generateRandomSelections(coursePoolSize, minSelections, maxSelections);
    plan.memberSelections.push(selections);
    plan.totalSelections += selections.length;
  }
  
  return plan;
};

export {
  PLANNER_CONSTANTS,
  extractPriceFromRow,
  getTeamMemberCount,
  getTeamMemberColumnIndex,
  generateRandomSelections,
  calculateExpectedTotal,
  generateTrainingPlan,
};