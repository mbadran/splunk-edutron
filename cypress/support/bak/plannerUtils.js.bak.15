/**
 * Planner Test Utilities - Pure Logic Functions
 *
 * Contains data extraction and calculation utilities for planner tests.
 * User actions and verifications are handled by Cypress commands.
 */

// Test timing and element constants
const PLANNER_CONSTANTS = {
  SELECTION_WAIT: 100,
  CALCULATOR_WAIT: 500,
  TEAM_ACTION_WAIT: 300,
  FOOTER_UPDATE_WAIT: 200,
  COMMAND_WAIT_TIME: 300, // General command operations
  LOAD_WAIT_TIME: 500, // Catalog loading operations
  TIMEOUT_MS: 15000, // All timeout operations
  FIRST_TEAM_MEMBER_COLUMN: 10,
  PRICE_COLUMN: 5,
  MAX_TEAM_MEMBERS: 20,
  MIN_COURSES_REQUIRED: 10, // Minimum courses needed for meaningful testing
  DEFAULT_TEAM_NAMES: [
    "Richard Hendricks",
    "Erlich Bachman",
    "Dinesh Chugtai",
    "Bertram Gilfoyle",
    "Jared Dunn",
    "Monica Hall",
    "Gavin Belson",
    "Nelson Bighetti",
    "Russ Hanneman",
    "Peter Gregory",
    "Laurie Bream",
    "Ed Chen",
    "Hoover Chan",
    "Don Bang",
    "Carla Walton",
    "Dan Melcher",
    "Fiona Wallace",
    "John Stafford",
    "Kara Swisher",
    "Maximo Reyes",
  ],
};

/**
 * Extract price from table row
 * Handles both "Free" courses and numeric prices
 */
const extractPriceFromRow = (rowIndex) => {
  return cy
    .get(`#table-row-${rowIndex}`)
    .find(`[aria-colindex="${PLANNER_CONSTANTS.PRICE_COLUMN}"]`)
    .invoke("text")
    .then((priceText) => {
      const cleanText = priceText.trim();

      if (cleanText === "Free" || cleanText === "") {
        return cy.then(() => 0);
      }

      const numericPrice = parseFloat(cleanText.replace(/[^0-9.]/g, ""));
      const finalPrice = isNaN(numericPrice) ? 0 : numericPrice;
      return cy.then(() => finalPrice);
    });
};

/**
 * Count team members using multiple detection methods
 * Primary: team-member-header class
 * Fallbacks: selection columns, name matching
 */
const getTeamMemberCount = () => {
  return cy.get("#monotable").then(() => {
    return cy.log("🔍 Counting team members").then(() => {
      // PRIMARY: Count team-member-header elements
      return cy.get(".team-member-header").then(($headers) => {
        const headerCount = $headers.length;

        if (headerCount > 0) {
          return cy
            .log(`📊 Found ${headerCount} team member headers`)
            .then(() => headerCount);
        } else {
          // FALLBACK: Count selection columns in first data row
          return cy
            .get('[id^="table-row-1"]')
            .first()
            .then(($row) => {
              if ($row.length > 0) {
                const selectionButtons = $row.find(
                  '[role="button"], .plan-cell-selected, .plan-cell-unselected',
                );
                const selectionCount = selectionButtons.length;

                if (selectionCount > 0) {
                  return cy
                    .log(
                      `📊 Fallback: Found ${selectionCount} selection columns`,
                    )
                    .then(() => selectionCount);
                }
              }

              // FINAL FALLBACK: Count by name matching
              return cy.get("#monotable").then(($table) => {
                const tableText = $table.text();
                let nameCount = 0;
                if (tableText.includes("Richard Hendricks")) nameCount++;
                for (let i = 2; i <= 10; i++) {
                  if (tableText.includes(`Team Member ${i}`)) nameCount++;
                }

                const finalCount = Math.max(nameCount, 1);
                return cy
                  .log(`📊 Final fallback: ${finalCount} team members`)
                  .then(() => finalCount);
              });
            });
        }
      });
    });
  });
};

/**
 * Calculate team member column index by name
 * Used for targeting specific team member columns in the table
 */
const getTeamMemberColumnIndex = (memberName) => {
  if (memberName === "Richard Hendricks") {
    return cy.then(() => PLANNER_CONSTANTS.FIRST_TEAM_MEMBER_COLUMN);
  }

  const match = memberName.match(/Team Member (\d+)/);
  if (match) {
    const memberNumber = parseInt(match[1]);
    const columnIndex =
      PLANNER_CONSTANTS.FIRST_TEAM_MEMBER_COLUMN + memberNumber - 1;
    return cy.then(() => columnIndex);
  }

  return cy.then(() => PLANNER_CONSTANTS.FIRST_TEAM_MEMBER_COLUMN);
};

/**
 * Generate random course selections for a team member
 * Returns array of unique row indices between 1 and poolSize
 */
const generateRandomSelections = (poolSize, minSelections, maxSelections) => {
  const selectionCount =
    Math.floor(Math.random() * (maxSelections - minSelections + 1)) +
    minSelections;
  const selections = [];

  while (selections.length < selectionCount) {
    const randomRow = Math.floor(Math.random() * poolSize) + 1;
    if (!selections.includes(randomRow)) {
      selections.push(randomRow);
    }
  }

  return selections.sort((a, b) => a - b);
};

/**
 * Calculate expected total for given selection arrays
 * Takes array of arrays (one per team member) of row indices
 */
const calculateExpectedTotal = (allMemberSelections) => {
  return cy.wrap(null).then(() => {
    let total = 0;
    let chain = cy.wrap(total);

    allMemberSelections.forEach((memberSelections) => {
      memberSelections.forEach((rowIndex) => {
        chain = chain.then((currentTotal) => {
          return extractPriceFromRow(rowIndex).then((price) => {
            return currentTotal + price;
          });
        });
      });
    });

    return chain;
  });
};

/**
 * Generate a realistic training plan with random selections per member
 * Returns object with member selections and expected totals
 */
const generateTrainingPlan = (
  teamCount,
  coursePoolSize,
  minSelections,
  maxSelections,
) => {
  const plan = {
    memberSelections: [],
    totalSelections: 0,
  };

  for (let i = 0; i < teamCount; i++) {
    const selections = generateRandomSelections(
      coursePoolSize,
      minSelections,
      maxSelections,
    );
    plan.memberSelections.push(selections);
    plan.totalSelections += selections.length;
  }

  return plan;
};

/**
 * FOOTER TESTING UTILITIES
 */

/**
 * Parse footer message and extract individual stat counts
 * Returns object with all numeric values found in footer
 */
const parseFooterMessage = (footerText) => {
  cy.log(`📊 Parsing footer message: "${footerText}"`);

  // Regex patterns for different stat types
  const patterns = {
    selections: /(\d+)\s+selections?/,
    teams: /(\d+)\s+teams?/,
    teamMembers: /(\d+)\s+team\s+members?/,
    catalogs: /(\d+)\s+catalogs?/,
    courses: /(\d+)\s+courses?/,
    filtered: /(\d+)\s+filtered/,
  };

  const results = {};

  Object.keys(patterns).forEach((key) => {
    const match = footerText.match(patterns[key]);
    results[key] = match ? parseInt(match[1]) : key === "filtered" ? null : 0;
  });

  cy.log(`📊 Parsed footer stats:`, results);
  return results;
};

/**
 * Generate expected footer message for given stats
 * Useful for testing footer message generation logic
 */
const generateExpectedFooterMessage = (stats) => {
  const parts = [];

  // Add selections if any exist
  if (stats.selections > 0) {
    const selectionText = stats.selections === 1 ? "selection" : "selections";
    parts.push(`${stats.selections} ${selectionText}`);
  }

  // Add team info
  if (stats.teams) {
    const teamText = stats.teams === 1 ? "team" : "teams";
    parts.push(`${stats.teams} ${teamText}`);
  }

  // Add team member info
  if (stats.teamMembers) {
    const memberText = stats.teamMembers === 1 ? "team member" : "team members";
    parts.push(`${stats.teamMembers} ${memberText}`);
  }

  // Add catalog info
  if (stats.catalogs) {
    const catalogText = stats.catalogs === 1 ? "catalog" : "catalogs";
    parts.push(`${stats.catalogs} ${catalogText}`);
  }

  // Add course info
  if (stats.courses) {
    const courseText = stats.courses === 1 ? "course" : "courses";
    parts.push(`${stats.courses} ${courseText}`);
  }

  // Add filtered info if applicable
  if (stats.filtered !== null && stats.filtered !== stats.courses) {
    parts.push(`${stats.filtered} filtered`);
  }

  return parts.join(" • ");
};

/**
 * Verify footer shows correct pluralization rules
 * Checks that singular/plural forms are used correctly
 */
const verifyFooterPluralization = (footerText, stats) => {
  const errors = [];

  // Check team members
  if (stats.teamMembers === 1) {
    if (footerText.includes("1 team members")) {
      errors.push('Should say "1 team member" not "1 team members"');
    }
  } else if (stats.teamMembers > 1) {
    if (
      footerText.includes(`${stats.teamMembers} team member`) &&
      !footerText.includes(`${stats.teamMembers} team members`)
    ) {
      errors.push(
        `Should say "${stats.teamMembers} team members" not "${stats.teamMembers} team member"`,
      );
    }
  }

  // Check selections
  if (stats.selections === 1) {
    if (footerText.includes("1 selections")) {
      errors.push('Should say "1 selection" not "1 selections"');
    }
  } else if (stats.selections > 1) {
    if (
      footerText.includes(`${stats.selections} selection`) &&
      !footerText.includes(`${stats.selections} selections`)
    ) {
      errors.push(
        `Should say "${stats.selections} selections" not "${stats.selections} selection"`,
      );
    }
  }

  // Check teams
  if (stats.teams === 1) {
    if (footerText.includes("1 teams")) {
      errors.push('Should say "1 team" not "1 teams"');
    }
  }

  return errors;
};

/**
 * Count total selections across all visible team member columns
 * Alternative method for validating selection counts
 */
const countVisibleSelections = () => {
  return cy.get("#monotable").then(() => {
    return cy.get(".plan-cell-selected, .bg-emerald-400").then(($selected) => {
      const count = $selected.length;
      cy.log(`📊 Counted ${count} visible selections`);
      return cy.wrap(count);
    });
  });
};

/**
 * Get current footer stats by parsing the actual footer element
 * More reliable than parsing text since it gets the live DOM content
 */
const getCurrentFooterStats = () => {
  return cy
    .get("#table-footer")
    .invoke("text")
    .then((footerText) => {
      return cy.wrap(parseFooterMessage(footerText));
    });
};

/**
 * Wait for footer to update after an action
 * Useful when testing dynamic footer updates
 */
const waitForFooterUpdate = (expectedChange, timeout = 2000) => {
  cy.log(`⏱️ Waiting for footer update: ${expectedChange}`);
  cy.wait(PLANNER_CONSTANTS.FOOTER_UPDATE_WAIT);

  // Optional: Add more sophisticated waiting logic here
  // For now, simple wait is sufficient given our app's responsiveness
};

/**
 * Compare two footer stat objects and return differences
 * Useful for validating expected changes
 */
const compareFooterStats = (beforeStats, afterStats) => {
  const differences = {};

  Object.keys(beforeStats).forEach((key) => {
    const before = beforeStats[key] || 0;
    const after = afterStats[key] || 0;

    if (before !== after) {
      differences[key] = {
        before,
        after,
        change: after - before,
      };
    }
  });

  return differences;
};

/**
 * Helper function to extract numeric values from footer text
 * Used by footer parsing commands
 */
const extractStat = (text, pattern) => {
  const match = text.match(pattern);
  return match ? parseInt(match[1]) : null;
};

/**
 * Add multiple team members in sequence
 * Common pattern used across multiple test suites
 */
const addMultipleTeamMembers = (count) => {
  return cy.wrap(null).then(() => {
    for (let i = 1; i < count; i++) {
      cy.addTeamMember();
      cy.wait(PLANNER_CONSTANTS.TEAM_ACTION_WAIT);
    }
  });
};

export {
  PLANNER_CONSTANTS,
  extractPriceFromRow,
  getTeamMemberCount,
  getTeamMemberColumnIndex,
  generateRandomSelections,
  calculateExpectedTotal,
  generateTrainingPlan,
  // Footer utilities
  parseFooterMessage,
  generateExpectedFooterMessage,
  verifyFooterPluralization,
  countVisibleSelections,
  getCurrentFooterStats,
  waitForFooterUpdate,
  compareFooterStats,
  extractStat,
  // Team utilities
  addMultipleTeamMembers,
};
