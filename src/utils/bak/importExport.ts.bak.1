import { z } from "zod";
import { Plan, PlanState, PlanMetadata, PlanTotals, Person, Course } from "@/types/types";
import { APP_VERSION } from "@/utils/constants";

// Zod schemas for import validation
const PersonSchema = z.object({
  id: z.string().min(1),
  name: z.string().min(1),
  email: z.string().optional(),
  role: z.string().optional(),
  teamId: z.string().min(1),
});

const PlanMetadataSchema = z.object({
  id: z.string().min(1),
  appVersion: z.string().min(1),
  exportedAt: z.string().min(1),
});

const PlanStateSchema = z.object({
  id: z.string().min(1),
  title: z.string().min(1),
  description: z.string().optional(),
  catalogs: z.array(z.string()).min(1),
  teams: z.array(z.string()).min(1),
  teamMembers: z.array(PersonSchema).min(1),
  selections: z.record(z.record(z.array(z.string()))),
  budget: z.number().nullable(),
  createdAt: z.string().min(1),
  updatedAt: z.string().min(1),
});

const PlanTotalsSchema = z.object({
  selectedCourses: z.number().min(0),
  totalCost: z.number().min(0),
  costPerMember: z.record(z.number()),
});

const PlanSchema = z.object({
  metadata: PlanMetadataSchema,
  state: PlanStateSchema,
  totals: PlanTotalsSchema,
});

// Import validation result
export interface ImportValidationResult {
  isValid: boolean;
  plan?: Plan;
  errors: string[];
  missingCourses: string[];
}

// Validate imported plan structure
export const validateImportedPlan = (data: unknown): ImportValidationResult => {
  const result: ImportValidationResult = {
    isValid: false,
    errors: [],
    missingCourses: [],
  };

  try {
    // Parse and validate the plan structure
    const plan = PlanSchema.parse(data);
    result.plan = plan;
    result.isValid = true;
  } catch (error) {
    if (error instanceof z.ZodError) {
      result.errors = error.errors.map(err => 
        `${err.path.join('.')}: ${err.message}`
      );
    } else {
      result.errors = [`Validation error: ${error}`];
    }
  }

  return result;
};

// Check if courses exist in current catalog
export const validateCourseExistence = (
  planSelections: Record<string, Record<string, string[]>>,
  availableCourses: Course[]
): string[] => {
  const missingCourses: Set<string> = new Set();
  const availableCourseIds = new Set(availableCourses.map(c => c.ID));

  // Check all course IDs in selections
  Object.values(planSelections).forEach(personSelections => {
    Object.values(personSelections).forEach(courseIds => {
      courseIds.forEach(courseId => {
        if (!availableCourseIds.has(courseId)) {
          missingCourses.add(courseId);
        }
      });
    });
  });

  return Array.from(missingCourses);
};

// Filter out missing courses from selections
export const filterMissingCourses = (
  planSelections: Record<string, Record<string, string[]>>,
  missingCourseIds: string[]
): Record<string, Record<string, string[]>> => {
  const missingSet = new Set(missingCourseIds);
  const filteredSelections: Record<string, Record<string, string[]>> = {};

  Object.entries(planSelections).forEach(([personId, personSelections]) => {
    const filteredPersonSelections: Record<string, string[]> = {};

    Object.entries(personSelections).forEach(([catalogId, courseIds]) => {
      const validCourseIds = courseIds.filter(courseId => !missingSet.has(courseId));
      
      // Only include catalogs that still have valid courses
      if (validCourseIds.length > 0) {
        filteredPersonSelections[catalogId] = validCourseIds;
      }
    });

    // Only include persons that still have valid selections
    if (Object.keys(filteredPersonSelections).length > 0) {
      filteredSelections[personId] = filteredPersonSelections;
    }
  });

  return filteredSelections;
};

// Check if current plan has any changes (non-default state)
export const hasNonDefaultPlanState = (planState: PlanState): boolean => {
  // Check if title is changed from default
  const hasCustomTitle = planState.title !== "Pied Piper / Splunk Training Plan";
  
  // Check if team members are changed (more than 1 or name changed)
  const hasCustomTeamMembers = planState.teamMembers.length > 1 || 
    (planState.teamMembers.length === 1 && planState.teamMembers[0].name !== "Richard Hendricks");
  
  // Check if any course selections exist
  const hasCourseSelections = Object.keys(planState.selections).length > 0;
  
  // Check if budget is set
  const hasBudget = planState.budget !== null;

  return hasCustomTitle || hasCustomTeamMembers || hasCourseSelections || hasBudget;
};

// Parse JSON file content
export const parseImportFile = async (file: File): Promise<unknown> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    
    reader.onload = (event) => {
      try {
        const content = event.target?.result as string;
        const parsed = JSON.parse(content);
        resolve(parsed);
      } catch (error) {
        reject(new Error(`Invalid JSON file: ${error}`));
      }
    };
    
    reader.onerror = () => {
      reject(new Error("Failed to read file"));
    };
    
    reader.readAsText(file);
  });
};

// Complete import validation with course checking
export const validateCompleteImport = (
  data: unknown,
  availableCourses: Course[]
): ImportValidationResult => {
  const structureResult = validateImportedPlan(data);
  
  if (!structureResult.isValid || !structureResult.plan) {
    return structureResult;
  }

  // Check for missing courses
  const missingCourses = validateCourseExistence(
    structureResult.plan.state.selections,
    availableCourses
  );

  return {
    ...structureResult,
    missingCourses,
  };
};