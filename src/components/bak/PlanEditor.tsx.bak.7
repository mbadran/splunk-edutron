import React, {
  useState,
  useEffect,
  useCallback,
  useMemo,
  useRef,
  useReducer,
} from "react";
import Header from "./Header";
import Catalog from "./Catalog";
import Team from "./Team";
import Footer from "./Footer";
import {
  ConfirmationModal,
  useConfirmationModal,
} from "./common/ConfirmationModal";
import { useScrollSync } from "./hooks/scrollSync";
import { Course, PlanState } from "./types";
import {
  DEFAULT_PLAN_TITLE,
  PAGE_TITLE_EDIT,
  DEFAULT_TEAM_NAMES,
} from "./constants";

// Constants
const RESIZE_BOUNDS = { min: 30, max: 70 };
const DEFAULT_LEFT_WIDTH = 50;

// Simplified history management with useReducer
interface HistoryState {
  past: PlanState[];
  present: PlanState;
  future: PlanState[];
}

type HistoryAction =
  | { type: "UPDATE"; payload: PlanState }
  | { type: "UNDO" }
  | { type: "REDO" }
  | { type: "RESET"; payload: PlanState };

const historyReducer = (
  state: HistoryState,
  action: HistoryAction,
): HistoryState => {
  console.log('ðŸ”§ PlanEditor historyReducer:', action.type, {
    pastLength: state.past.length,
    futureLength: state.future.length,
    timestamp: Date.now()
  });

  switch (action.type) {
    case "UPDATE": {
      const { payload } = action;
      // Don't add to history if state hasn't changed
      if (JSON.stringify(state.present) === JSON.stringify(payload)) {
        console.log('ðŸ”§ PlanEditor historyReducer: UPDATE skipped - no change');
        return state;
      }

      console.log('ðŸ”§ PlanEditor historyReducer: UPDATE applied');
      return {
        past: [...state.past, state.present].slice(-50), // Keep max 50 items
        present: payload,
        future: [],
      };
    }

    case "UNDO": {
      if (state.past.length === 0) return state;

      const previous = state.past[state.past.length - 1];
      const newPast = state.past.slice(0, state.past.length - 1);

      return {
        past: newPast,
        present: previous,
        future: [state.present, ...state.future],
      };
    }

    case "REDO": {
      if (state.future.length === 0) return state;

      const next = state.future[0];
      const newFuture = state.future.slice(1);

      return {
        past: [...state.past, state.present],
        present: next,
        future: newFuture,
      };
    }

    case "RESET": {
      return {
        past: [],
        present: action.payload,
        future: [],
      };
    }

    default:
      return state;
  }
};

interface PlanScrollerProps {
  courseCount: number;
  courses: Course[];
  teamMembers: string[];
  selections: Record<string, boolean>;
  onCoursesLoad: (count: number, courses: Course[]) => void;
  onTeamMembersChange: (members: string[]) => void;
  onSelectionsChange: (selections: Record<string, boolean>) => void;
}

// Remove React.memo to ensure proper re-renders
const PlanScroller: React.FC<PlanScrollerProps> = ({
  courseCount,
  courses,
  teamMembers,
  selections,
  onCoursesLoad,
  onTeamMembersChange,
  onSelectionsChange,
}) => {
  const renderCountRef = useRef(0);
  renderCountRef.current++;
  
  console.log('ðŸ”§ PlanScroller render:', {
    renderCount: renderCountRef.current,
    courseCount,
    coursesLength: courses.length,
    teamMembersLength: teamMembers.length,
    selectionsKeys: Object.keys(selections).length,
    timestamp: Date.now()
  });

  const [isResizing, setIsResizing] = useState(false);
  const [leftWidth, setLeftWidth] = useState(DEFAULT_LEFT_WIDTH);
  const containerRef = useRef<HTMLDivElement>(null);

  const {
    catalogTableRef,
    teamTableRef,
    handleCatalogScroll,
    handleTeamScroll,
  } = useScrollSync();

  // Improved resize handling
  const handleMouseMove = useCallback(
    (e: MouseEvent) => {
      if (!isResizing || !containerRef.current) return;

      const containerRect = containerRef.current.getBoundingClientRect();
      const newLeftWidth =
        ((e.clientX - containerRect.left) / containerRect.width) * 100;

      if (
        newLeftWidth >= RESIZE_BOUNDS.min &&
        newLeftWidth <= RESIZE_BOUNDS.max
      ) {
        setLeftWidth(newLeftWidth);
      }
    },
    [isResizing],
  );

  const handleMouseUp = useCallback(() => {
    setIsResizing(false);
    document.body.style.cursor = "";
    document.body.style.userSelect = "";
  }, []);

  const handleMouseDown = useCallback((e: React.MouseEvent) => {
    e.preventDefault();
    setIsResizing(true);
    document.body.style.cursor = "col-resize";
    document.body.style.userSelect = "none";
  }, []);

  // FIXED: Stable selection handlers - no dependency on selections
  const handleToggleSelection = useCallback(
    (courseIndex: number, memberIndex: number) => {
      console.log('ðŸ”§ PlanScroller handleToggleSelection:', courseIndex, memberIndex);
      const key = `${courseIndex}-${memberIndex}`;
      onSelectionsChange((prev: Record<string, boolean>) => ({
        ...prev,
        [key]: !prev[key],
      }));
    },
    [onSelectionsChange],
  );

  const isSelected = useCallback(
    (courseIndex: number, memberIndex: number) => {
      const key = `${courseIndex}-${memberIndex}`;
      return Boolean(selections[key]);
    },
    [selections],
  );

  // Event listeners for resize
  useEffect(() => {
    if (isResizing) {
      const handleGlobalMouseMove = (e: MouseEvent) => handleMouseMove(e);
      const handleGlobalMouseUp = () => handleMouseUp();

      document.addEventListener("mousemove", handleGlobalMouseMove);
      document.addEventListener("mouseup", handleGlobalMouseUp);

      return () => {
        document.removeEventListener("mousemove", handleGlobalMouseMove);
        document.removeEventListener("mouseup", handleGlobalMouseUp);
      };
    }
  }, [isResizing, handleMouseMove, handleMouseUp]);

  return (
    <div
      ref={containerRef}
      className="h-[70vh] training-plan-container flex relative"
    >
      <div
        className="h-full overflow-hidden catalog-scroll-container"
        style={{ width: `${leftWidth}%` }}
      >
        <div className="bg-white h-full">
          <Catalog
            ref={catalogTableRef}
            onCoursesLoad={onCoursesLoad}
            onScroll={handleCatalogScroll}
          />
        </div>
      </div>

      <div
        className="bg-gradient-to-b from-orange-500 to-pink-500 cursor-col-resize hover:from-orange-600 hover:to-pink-600 transition-colors duration-150 group relative flex-shrink-0 flex items-center justify-center hover:cursor-grab active:cursor-grabbing"
        style={{ width: "10px" }}
        onMouseDown={handleMouseDown}
      >
        <div
          className="bg-orange-500 rounded-md shadow-lg group-hover:bg-orange-600 transition-colors duration-150 flex flex-col items-center justify-center z-10 border border-orange-400 gap-1"
          style={{ width: "14px", height: "32px" }}
        >
          <div className="w-1 h-1 bg-amber-800 rounded-full"></div>
          <div className="w-1 h-1 bg-amber-800 rounded-full"></div>
          <div className="w-1 h-1 bg-amber-800 rounded-full"></div>
        </div>
      </div>

      <div
        className="h-full overflow-hidden team-scroll-container"
        style={{ width: `${100 - leftWidth}%` }}
      >
        <div className="bg-white h-full">
          <Team
            ref={teamTableRef}
            courses={courses}
            courseCount={courseCount}
            teamMembers={teamMembers}
            selections={selections}
            onTeamMembersChange={onTeamMembersChange}
            onToggleSelection={handleToggleSelection}
            isSelected={isSelected}
            onScroll={handleTeamScroll}
          />
        </div>
      </div>
    </div>
  );
};

PlanScroller.displayName = "PlanScroller";

interface PlanEditorProps {
  onBackToWelcome: () => void;
  hasExistingPlan: boolean;
}

// Utility function to create initial state
const createInitialState = (): PlanState => ({
  title: DEFAULT_PLAN_TITLE,
  courseCount: 0,
  teamMembers: [DEFAULT_TEAM_NAMES[0]],
  selections: {},
});

const PlanEditor: React.FC<PlanEditorProps> = ({
  onBackToWelcome,
  hasExistingPlan,
}) => {
  const renderCountRef = useRef(0);
  renderCountRef.current++;
  
  console.log('ðŸ”§ PlanEditor render:', {
    renderCount: renderCountRef.current,
    hasExistingPlan,
    timestamp: Date.now()
  });

  const initialState = useMemo(() => {
    console.log('ðŸ”§ PlanEditor createInitialState');
    return createInitialState();
  }, []);

  // Use reducer for history management
  const [history, dispatchHistory] = useReducer(historyReducer, {
    past: [],
    present: initialState,
    future: [],
  });

  // Separate state for courses and budget (not part of history)
  const [courses, setCourses] = useState<Course[]>([]);
  const [budget, setBudget] = useState<number | null>(null);

  const {
    showConfirmation,
    showConfirmationModal,
    handleConfirmAction,
    handleCancelAction,
    confirmationTitle,
    confirmationMessage,
  } = useConfirmationModal();

  // Extract current state values
  const {
    title: planTitle,
    courseCount,
    teamMembers,
    selections,
  } = history.present;

  // Memoize hasChanges calculation
  const hasChanges = useMemo(() => {
    const result = JSON.stringify(history.present) !== JSON.stringify(initialState);
    console.log('ðŸ”§ PlanEditor hasChanges calculated:', result);
    return result;
  }, [history.present, initialState]);

  // Memoize total calculation
  const total = useMemo(() => {
    const result = Object.entries(selections).reduce((acc, [key, isSelected]) => {
      if (!isSelected) return acc;

      const [courseIndexStr] = key.split("-");
      const courseIndex = parseInt(courseIndexStr, 10);
      const course = courses[courseIndex];

      return acc + (course?.Price || 0);
    }, 0);
    console.log('ðŸ”§ PlanEditor total calculated:', result);
    return result;
  }, [selections, courses]);

  // History actions
  const canUndo = history.past.length > 0;
  const canRedo = history.future.length > 0;

  // Set page title on mount
  useEffect(() => {
    console.log('ðŸ”§ PlanEditor setting page title');
    document.title = PAGE_TITLE_EDIT;
  }, []);

  // Handle browser back button
  useEffect(() => {
    console.log('ðŸ”§ PlanEditor setting up popstate handler, hasChanges:', hasChanges);
    
    const handlePopState = (e: PopStateEvent) => {
      console.log('ðŸ”§ PlanEditor popstate event, hasChanges:', hasChanges);
      e.preventDefault();
      if (hasChanges) {
        showConfirmationModal(
          () => onBackToWelcome(),
          "Unsaved Changes!",
          "We recommend downloading your current plan before continuing. Are you sure you want to leave?",
        );
        // Push the state back to prevent navigation
        window.history.pushState({ view: "edit" }, "", "#edit");
      } else {
        onBackToWelcome();
      }
    };

    window.addEventListener("popstate", handlePopState);
    return () => {
      console.log('ðŸ”§ PlanEditor removing popstate handler');
      window.removeEventListener("popstate", handlePopState);
    };
  }, [hasChanges, showConfirmationModal, onBackToWelcome]);

  // FIXED: Stable update function that doesn't recreate
  const updateState = useCallback(
    (updates: Partial<PlanState>) => {
      console.log('ðŸ”§ PlanEditor updateState:', updates);
      dispatchHistory({ 
        type: "UPDATE", 
        payload: { ...history.present, ...updates } 
      });
    },
    [history.present],
  );

  const handleUpdateTitle = useCallback(
    (newTitle: string) => {
      console.log('ðŸ”§ PlanEditor handleUpdateTitle:', newTitle);
      updateState({ title: newTitle });
    },
    [updateState],
  );

  const handleDownload = useCallback(() => {
    console.log('ðŸ”§ PlanEditor handleDownload');
    alert("Coming soon!");
  }, []);

  // FIXED: Simplified courses load handler to prevent cascading updates
  const handleCoursesLoad = useCallback(
    (count: number, newCourses: Course[]) => {
      console.log('ðŸ”§ PlanEditor handleCoursesLoad:', {
        count,
        newCoursesLength: newCourses.length,
        currentCourseCount: courseCount,
        currentCoursesLength: courses.length
      });
      
      // Update courses immediately
      setCourses(newCourses);
      
      // Only update courseCount if it's actually different
      if (count !== courseCount) {
        console.log('ðŸ”§ PlanEditor updating courseCount from', courseCount, 'to', count);
        updateState({ courseCount: count });
      }
    },
    [courseCount, updateState, courses.length],
  );

  const handleTeamMembersChange = useCallback(
    (newTeamMembers: string[]) => {
      console.log('ðŸ”§ PlanEditor handleTeamMembersChange:', newTeamMembers);
      updateState({ teamMembers: newTeamMembers });
    },
    [updateState],
  );

  // FIXED: Completely stable selections handler
  const handleSelectionsChange = useCallback(
    (updater: Record<string, boolean> | ((prev: Record<string, boolean>) => Record<string, boolean>)) => {
      console.log('ðŸ”§ PlanEditor handleSelectionsChange called');
      
      if (typeof updater === 'function') {
        // Use the functional form to avoid dependency on selections
        dispatchHistory(prevHistory => {
          const newSelections = updater(prevHistory.present.selections);
          console.log('ðŸ”§ PlanEditor functional update selections');
          return {
            type: "UPDATE",
            payload: { ...prevHistory.present, selections: newSelections }
          };
        });
      } else {
        console.log('ðŸ”§ PlanEditor direct update selections');
        updateState({ selections: updater });
      }
    },
    [updateState],
  );

  const handleBudgetChange = useCallback((newBudget: number | null) => {
    console.log('ðŸ”§ PlanEditor handleBudgetChange:', newBudget);
    setBudget(newBudget);
  }, []);

  const handleUndo = useCallback(() => {
    console.log('ðŸ”§ PlanEditor handleUndo');
    dispatchHistory({ type: "UNDO" });
  }, []);

  const handleRedo = useCallback(() => {
    console.log('ðŸ”§ PlanEditor handleRedo');
    dispatchHistory({ type: "REDO" });
  }, []);

  const handleBackToWelcome = useCallback(() => {
    console.log('ðŸ”§ PlanEditor handleBackToWelcome, hasChanges:', hasChanges);
    if (hasChanges) {
      showConfirmationModal(
        () => onBackToWelcome(),
        "Unsaved Changes!",
        "We recommend downloading your current plan before continuing. Are you sure you want to leave?",
      );
    } else {
      onBackToWelcome();
    }
  }, [hasChanges, showConfirmationModal, onBackToWelcome]);

  console.log('ðŸ”§ PlanEditor about to render, state:', {
    planTitle,
    courseCount,
    teamMembersLength: teamMembers.length,
    selectionsKeys: Object.keys(selections).length,
    coursesLength: courses.length,
    total,
    canUndo,
    canRedo
  });

  return (
    <div className="min-h-screen bg-gray-50 flex flex-col">
      <Header
        onBackToWelcome={handleBackToWelcome}
        planTitle={planTitle}
        onUpdateTitle={handleUpdateTitle}
        onUndo={handleUndo}
        onRedo={handleRedo}
        onDownload={handleDownload}
        canUndo={canUndo}
        canRedo={canRedo}
        total={total}
        onBudgetChange={handleBudgetChange}
      />

      <PlanScroller
        courseCount={courseCount}
        courses={courses}
        teamMembers={teamMembers}
        selections={selections}
        onCoursesLoad={handleCoursesLoad}
        onTeamMembersChange={handleTeamMembersChange}
        onSelectionsChange={handleSelectionsChange}
      />

      <div className="mt-16">
        <Footer />
      </div>

      <ConfirmationModal
        isOpen={showConfirmation}
        onClose={handleCancelAction}
        onConfirm={handleConfirmAction}
        title={confirmationTitle}
        message={confirmationMessage}
      />
    </div>
  );
};

export default PlanEditor;