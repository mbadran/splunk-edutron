import React, { useState, useEffect, useCallback, forwardRef, useImperativeHandle, useRef } from 'react';
import { Clock, DollarSign, ExternalLink, GraduationCap } from 'lucide-react';
import Papa from 'papaparse';
import {
  useReactTable,
  getCoreRowModel,
  createColumnHelper,
  flexRender,
  ColumnDef,
} from '@tanstack/react-table';

// Conditional import for react-virtual with fallback
let useVirtualizer: any = null;
try {
  const reactVirtual = require('@tanstack/react-virtual');
  useVirtualizer = reactVirtual.useVirtualizer;
} catch (e) {
  // Create a dummy hook that returns null to maintain hook consistency
  useVirtualizer = () => null;
}

interface Course {
  ID: string;
  Name: string;
  Category: string;
  Duration: number;
  Mode: string;
  Price: number;
  STEP_ID?: string;
}

interface CatalogProps {
  onCoursesLoad?: (count: number, courses: Course[]) => void;
  onScroll?: (scrollTop: number) => void;
}

interface CatalogRef {
  scrollToOffset: (offset: number) => void;
}

const loadCoursesFromCSV = async (): Promise<Course[]> => {
  try {
    const response = await fetch('/catalog.csv');
    if (!response.ok) {
      throw new Error(`Failed to load catalog.csv: ${response.status}`);
    }
    const text = await response.text();
    
    return new Promise((resolve, reject) => {
      Papa.parse(text, {
        header: true,
        skipEmptyLines: true,
        dynamicTyping: true,
        trimHeaders: true,
        delimitersToGuess: [',', '\t', '|', ';'],
        transform: (value, header) => {
          if (typeof value === 'string') {
            return value.trim();
          }
          return value;
        },
        complete: (results) => {
          try {
            const courses: Course[] = [];
            
            for (const row of results.data as any[]) {
              // Handle STEP ID column name variations
              if (row['STEP ID']) {
                row.STEP_ID = row['STEP ID'];
                delete row['STEP ID'];
              }
              if (row['Step ID']) {
                row.STEP_ID = row['Step ID'];
                delete row['Step ID'];
              }
              if (row['step_id']) {
                row.STEP_ID = row['step_id'];
                delete row['step_id'];
              }
              
              // Only include rows with required fields
              if (row.ID && row.Name) {
                const course: Course = {
                  ID: String(row.ID || '').trim(),
                  Name: String(row.Name || '').trim(),
                  Category: String(row.Category || '').trim(),
                  Duration: Number(row.Duration) || 0,
                  Mode: String(row.Mode || '').trim(),
                  Price: Number(row.Price) || 0,
                  STEP_ID: row.STEP_ID ? String(row.STEP_ID).trim() : undefined
                };
                
                courses.push(course);
              }
            }
            
            if (courses.length === 0) {
              reject(new Error('No valid courses found in catalog.csv'));
            } else {
              resolve(courses);
            }
          } catch (error) {
            reject(error);
          }
        },
        error: (error) => {
          reject(new Error(`CSV parsing error: ${error.message}`));
        }
      });
    });
  } catch (error) {
    console.error('Error loading course catalog:', error);
    throw error;
  }
};

const Catalog = forwardRef<CatalogRef, CatalogProps>(({ onCoursesLoad, onScroll }, ref) => {
  const [courses, setCourses] = useState<Course[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [hasLoaded, setHasLoaded] = useState(false);

  const tableContainerRef = useRef<HTMLDivElement>(null);
  const onCoursesLoadRef = useRef(onCoursesLoad);
  const onScrollRef = useRef(onScroll);
  const isLoadingRef = useRef(false);

  // Update refs when props change
  useEffect(() => {
    onCoursesLoadRef.current = onCoursesLoad;
  }, [onCoursesLoad]);

  useEffect(() => {
    onScrollRef.current = onScroll;
  }, [onScroll]);

  const columnHelper = createColumnHelper<Course>();

  const generateCourseUrl = useCallback((stepId: string): string => {
    if (!stepId) return '#';
    return `https://education.splunk.com/Saba/Web_spf/NA10P2PRD105/guestapp/ledetail/${stepId}?utm_source=splunk-edutron`;
  }, []);

  const getCategoryColor = useCallback((category: string): string => {
    const colors: Record<string, string> = {
      'Core': 'bg-orange-500 text-white',
      'Power User': 'bg-blue-500 text-white',
      'Admin': 'bg-green-500 text-white',
      'Security': 'bg-red-500 text-white',
      'ITSI': 'bg-purple-500 text-white',
      'Platform': 'bg-indigo-500 text-white',
      'Observability': 'bg-teal-500 text-white',
      'Cloud': 'bg-cyan-500 text-white'
    };
    return colors[category] || 'bg-gray-500 text-white';
  }, []);

  const getModeColor = useCallback((mode: string): string => {
    const colors: Record<string, string> = {
      'E': 'bg-blue-100 text-blue-800',
      'EL': 'bg-purple-100 text-purple-800',
      'ILT': 'bg-green-100 text-green-800'
    };
    return colors[mode] || 'bg-gray-100 text-gray-800';
  }, []);

  const getModeTooltip = useCallback((mode: string): string => {
    const tooltips: Record<string, string> = {
      'E': 'eLearning (No Labs)',
      'EL': 'eLearning (With Labs)', 
      'ILT': 'Instructor-Led Training'
    };
    return tooltips[mode] || mode;
  }, []);

  const formatPrice = useCallback((price: number): string => {
    return price.toLocaleString('en-US');
  }, []);

  const columns = React.useMemo<ColumnDef<Course>[]>(() => [
    columnHelper.accessor('ID', {
      header: 'ID',
      cell: info => (
        <code className="text-sm font-mono text-gray-700 bg-gray-200 px-2 py-1 rounded whitespace-nowrap">
          {info.getValue()}
        </code>
      ),
      size: 120,
      minSize: 120,
      maxSize: 120,
    }),
    columnHelper.accessor('Category', {
      header: 'Category',
      cell: info => (
        <span className={`px-2 py-1 rounded-full text-xs font-medium whitespace-nowrap ${getCategoryColor(info.getValue())}`}>
          {info.getValue()}
        </span>
      ),
      size: 120,
      minSize: 120,
      maxSize: 120,
    }),
    columnHelper.accessor('Mode', {
      header: 'Mode',
      cell: info => (
        <span 
          className={`px-2 py-1 rounded-full text-xs font-medium whitespace-nowrap cursor-help ${getModeColor(info.getValue())}`}
          title={getModeTooltip(info.getValue())}
        >
          {info.getValue()}
        </span>
      ),
      size: 80,
      minSize: 80,
      maxSize: 80,
    }),
    columnHelper.accessor('Duration', {
      header: 'Duration',
      cell: info => (
        <div className="relative bg-yellow-100 px-2 py-1 rounded inline-block">
          <Clock className="absolute left-1 top-1/2 transform -translate-y-1/2 w-3 h-3 text-gray-600 opacity-80" />
          <span className="text-sm font-medium text-gray-700 pl-4">
            {info.getValue()}h
          </span>
        </div>
      ),
      size: 120,
      minSize: 120,
      maxSize: 120,
    }),
    columnHelper.accessor('Price', {
      header: 'Price',
      cell: info => (
        <div className="flex items-center">
          {info.getValue() === 0 ? (
            <span className="text-gray-700 font-medium text-sm bg-green-200 px-2 py-1 rounded whitespace-nowrap">
              Free
            </span>
          ) : (
            <div className="flex items-center text-gray-700 bg-pink-200 px-2 py-1 rounded">
              <DollarSign className="w-3 h-3 mr-1" />
              <span className="font-medium text-sm font-mono">
                {formatPrice(info.getValue())}
              </span>
            </div>
          )}
        </div>
      ),
      size: 100,
      minSize: 100,
      maxSize: 100,
    }),
    columnHelper.accessor('Name', {
      header: 'Course',
      cell: info => {
        const course = info.row.original;
        return (
          <div className="whitespace-nowrap overflow-hidden">
            {course.STEP_ID ? (
              <a 
                href={generateCourseUrl(course.STEP_ID)}
                target="_blank"
                rel="noopener noreferrer"
                className="text-orange-600 hover:text-orange-800 font-medium flex items-center gap-1 group"
                title={course.Name}
              >
                <span className="truncate">{course.Name}</span>
                <ExternalLink className="w-3 h-3 opacity-0 group-hover:opacity-100 transition-opacity flex-shrink-0" />
              </a>
            ) : (
              <span className="font-medium text-gray-900 truncate block" title={course.Name}>
                {course.Name}
              </span>
            )}
          </div>
        );
      },
      size: 350,
      minSize: 350,
      maxSize: 350,
    }),
  ], [columnHelper, getCategoryColor, getModeColor, getModeTooltip, formatPrice, generateCourseUrl]);

  const table = useReactTable({
    data: courses,
    columns,
    getCoreRowModel: getCoreRowModel(),
  });

  const { rows } = table.getRowModel();

  // Always call useVirtualizer hook to maintain hook order
  const rowVirtualizer = useVirtualizer({
    count: rows.length,
    getScrollElement: () => tableContainerRef.current,
    estimateSize: () => 48,
    overscan: 10,
  });

  useImperativeHandle(ref, () => ({
    scrollToOffset: (offset: number) => {
      if (tableContainerRef.current) {
        tableContainerRef.current.scrollTop = offset;
      }
    }
  }));

  const loadCourses = useCallback(async () => {
    // Prevent multiple simultaneous loads
    if (isLoadingRef.current) {
      return;
    }

    try {
      isLoadingRef.current = true;
      setIsLoading(true);
      setError(null);
      
      const loadedCourses = await loadCoursesFromCSV();
      
      if (loadedCourses.length === 0) {
        throw new Error('No courses found in catalog.csv');
      }
      
      const sortedCourses = loadedCourses.sort((a, b) => a.Name.localeCompare(b.Name));
      
      setCourses(sortedCourses);
      setHasLoaded(true);
      
      // Use ref to avoid dependency issues
      if (onCoursesLoadRef.current) {
        onCoursesLoadRef.current(sortedCourses.length, sortedCourses);
      }
      
    } catch (err) {
      const errorMessage = `Failed to load catalog: ${(err as Error).message}`;
      setError(errorMessage);
      console.error('Catalog loading error:', err);
    } finally {
      setIsLoading(false);
      isLoadingRef.current = false;
    }
  }, []); // No dependencies to prevent infinite loops

  useEffect(() => {
    if (!hasLoaded) {
      loadCourses();
    }
  }, [loadCourses, hasLoaded]);

  const handleScroll = useCallback((e: React.UIEvent<HTMLDivElement>) => {
    if (onScrollRef.current) {
      onScrollRef.current(e.currentTarget.scrollTop);
    }
  }, []);

  const handleRetry = useCallback(() => {
    setHasLoaded(false);
    loadCourses();
  }, [loadCourses]);

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-full">
        <div className="text-center">
          <div className="w-8 h-8 border-2 border-gray-300 border-t-gray-600 rounded-full animate-spin mx-auto mb-4"></div>
          <p className="text-gray-600">Loading course catalog...</p>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex items-center justify-center h-full p-4">
        <div className="max-w-md mx-auto text-center">
          <div className="bg-white/10 backdrop-blur-md rounded-3xl p-8 shadow-2xl border border-white/20">
            <div className="inline-flex items-center justify-center w-16 h-16 bg-white/20 backdrop-blur-sm rounded-2xl mb-6">
              <GraduationCap className="w-8 h-8 text-gray-600" />
            </div>
            <div className="text-red-400 mb-4 text-2xl">⚠️ Error</div>
            <p className="text-gray-600 mb-4">{error}</p>
            <p className="text-gray-500 text-sm mb-6">
              Make sure catalog.csv is in your /public directory
            </p>
            <div className="space-y-3">
              <button 
                onClick={handleRetry}
                className="w-full bg-orange-500 text-white hover:bg-orange-600 font-semibold py-3 px-6 rounded-lg transition-colors"
              >
                Retry Loading
              </button>
            </div>
          </div>
        </div>
      </div>
    );
  }

  // Render with or without virtualization
  if (rowVirtualizer && rowVirtualizer.getVirtualItems && rowVirtualizer.getTotalSize) {
    return (
      <div className="flex flex-col h-full">
        <div className="flex-1 overflow-hidden relative">
          <div 
            ref={tableContainerRef}
            className="h-full overflow-y-auto catalog-scroll-container"
            onScroll={handleScroll}
            style={{ position: 'relative' }}
          >
            {/* Fixed Header */}
            <div className="sticky top-0 left-0 right-0 z-50 bg-slate-800 shadow-lg">
              <table className="w-full min-w-[900px]">
                <thead>
                  {table.getHeaderGroups().map(headerGroup => (
                    <tr key={headerGroup.id}>
                      {headerGroup.headers.map(header => (
                        <th
                          key={header.id}
                          className="px-4 py-3 text-left font-semibold bg-slate-800 text-white border-r border-slate-700"
                          style={{
                            width: header.getSize(),
                            minWidth: header.getSize(),
                            maxWidth: header.getSize(),
                          }}
                        >
                          {header.isPlaceholder
                            ? null
                            : flexRender(
                                header.column.columnDef.header,
                                header.getContext()
                              )}
                        </th>
                      ))}
                    </tr>
                  ))}
                </thead>
              </table>
            </div>

            {/* Scrollable Body */}
            <div className="relative" style={{ height: `${rowVirtualizer.getTotalSize()}px` }}>
              <table className="w-full min-w-[900px]">
                <thead className="invisible">
                  {table.getHeaderGroups().map(headerGroup => (
                    <tr key={headerGroup.id}>
                      {headerGroup.headers.map(header => (
                        <th
                          key={header.id}
                          className="px-4 py-3"
                          style={{
                            width: header.getSize(),
                            minWidth: header.getSize(),
                            maxWidth: header.getSize(),
                          }}
                        >
                          {/* Invisible spacer to maintain column alignment */}
                        </th>
                      ))}
                    </tr>
                  ))}
                </thead>
                <tbody>
                  {rowVirtualizer.getVirtualItems().map((virtualRow: any) => {
                    const row = rows[virtualRow.index];
                    return (
                      <tr
                        key={row.id}
                        className={`h-12 border-b border-gray-200 ${
                          virtualRow.index % 2 === 0 ? 'bg-white' : 'bg-gray-50'
                        } hover:bg-orange-50 transition-colors`}
                        style={{
                          position: 'absolute',
                          transform: `translateY(${virtualRow.start}px)`,
                          width: '100%',
                        }}
                      >
                        {row.getVisibleCells().map(cell => (
                          <td
                            key={cell.id}
                            className="px-4 py-2"
                            style={{
                              width: cell.column.getSize(),
                              minWidth: cell.column.getSize(),
                              maxWidth: cell.column.getSize(),
                            }}
                          >
                            {flexRender(cell.column.columnDef.cell, cell.getContext())}
                          </td>
                        ))}
                      </tr>
                    );
                  })}
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
    );
  }

  // Fallback render without virtualization
  return (
    <div className="flex flex-col h-full">
      <div className="flex-1 overflow-hidden relative">
        <div 
          ref={tableContainerRef}
          className="h-full overflow-y-auto catalog-scroll-container"
          onScroll={handleScroll}
          style={{ position: 'relative' }}
        >
          {/* Fixed Header */}
          <div className="sticky top-0 left-0 right-0 z-50 bg-slate-800 shadow-lg">
            <table className="w-full min-w-[900px]">
              <thead>
                {table.getHeaderGroups().map(headerGroup => (
                  <tr key={headerGroup.id}>
                    {headerGroup.headers.map(header => (
                      <th
                        key={header.id}
                        className="px-4 py-3 text-left font-semibold bg-slate-800 text-white border-r border-slate-700"
                        style={{
                          width: header.getSize(),
                          minWidth: header.getSize(),
                          maxWidth: header.getSize(),
                        }}
                      >
                        {header.isPlaceholder
                          ? null
                          : flexRender(
                              header.column.columnDef.header,
                              header.getContext()
                            )}
                      </th>
                    ))}
                  </tr>
                ))}
              </thead>
            </table>
          </div>

          {/* Scrollable Body */}
          <table className="w-full min-w-[900px]">
            <thead className="invisible">
              {table.getHeaderGroups().map(headerGroup => (
                <tr key={headerGroup.id}>
                  {headerGroup.headers.map(header => (
                    <th
                      key={header.id}
                      className="px-4 py-3"
                      style={{
                        width: header.getSize(),
                        minWidth: header.getSize(),
                        maxWidth: header.getSize(),
                      }}
                    >
                      {/* Invisible spacer to maintain column alignment */}
                    </th>
                  ))}
                </tr>
              ))}
            </thead>
            <tbody>
              {rows.map((row, index) => (
                <tr
                  key={row.id}
                  className={`h-12 border-b border-gray-200 ${
                    index % 2 === 0 ? 'bg-white' : 'bg-gray-50'
                  } hover:bg-orange-50 transition-colors`}
                >
                  {row.getVisibleCells().map(cell => (
                    <td
                      key={cell.id}
                      className="px-4 py-2"
                      style={{
                        width: cell.column.getSize(),
                        minWidth: cell.column.getSize(),
                        maxWidth: cell.column.getSize(),
                      }}
                    >
                      {flexRender(cell.column.columnDef.cell, cell.getContext())}
                    </td>
                  ))}
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </div>
    </div>
  );
});

Catalog.displayName = 'Catalog';

export default Catalog;