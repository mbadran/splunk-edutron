import React, {
  useRef,
  useEffect,
  useState,
  forwardRef,
  useImperativeHandle,
  useMemo,
  useCallback,
} from "react";
import {
  Table,
  flexRender,
  ColumnResizeMode,
  Column,
} from "@tanstack/react-table";
import { GripVertical, ArrowUpDown, ArrowUp, ArrowDown } from "lucide-react";

// Constants - Now properly exported
export const TABLE_CONSTANTS = {
  CONTAINER_HEIGHT: 400,
  VIEWPORT_HEIGHT_RATIO: 0.7,
  HEADER_OFFSET: 48,
  ROW_HEIGHT: 48,
  COLUMN_WIDTH: {
    XSMALL: 60,
    SMALL: 80,
    MEDIUM: 120,
    LARGE: 150,
    XLARGE: 200,
    XXLARGE: 350,
  },
  COLUMN_LIMITS: {
    MIN_XSMALL: 40,
    MIN_SMALL: 60,
    MIN_MEDIUM: 80,
    MIN_LARGE: 100,
    MIN_XLARGE: 150,
    MIN_XXLARGE: 200,
    MAX_XSMALL: 80,
    MAX_SMALL: 100,
    MAX_MEDIUM: 150,
    MAX_LARGE: 200,
    MAX_XLARGE: 300,
    MAX_XXLARGE: 500,
  },
  SCROLL_THROTTLE_MS: 16, // ~60fps
};

export interface BaseTableRef {
  scrollToOffset: (offset: number) => void;
}

interface BaseTableProps<TData> {
  table: Table<TData>;
  onScroll?: (scrollTop: number) => void;
  headerClassName?: string;
  containerClassName?: string;
  rowHeight?: number;
  renderFooter?: () => React.ReactNode;
  columnResizeMode?: ColumnResizeMode;
  emptyStateMessage?: string;
  loadingState?: boolean;
}

export const SortableHeader = <TData,>({
  column,
  children,
  showDragHandle = false,
}: {
  column: Column<TData, unknown>;
  children: React.ReactNode;
  showDragHandle?: boolean;
}) => {
  const isSorted = column.getIsSorted();
  const canSort = column.getCanSort();

  // Use TanStack's native sorting handler
  const sortHandler = column.getToggleSortingHandler();

  const sortIcon = useMemo(() => {
    if (isSorted === "asc") return <ArrowUp className="w-3 h-3" />;
    if (isSorted === "desc") return <ArrowDown className="w-3 h-3" />;
    return <ArrowUpDown className="w-3 h-3 opacity-50" />;
  }, [isSorted]);

  return (
    <div className="flex items-center gap-2 w-full">
      {showDragHandle && (
        <div
          className="cursor-grab hover:cursor-grab active:cursor-grabbing p-1 hover:bg-slate-600 rounded transition-colors opacity-50 hover:opacity-100"
          title="Drag to reorder column"
          role="button"
          tabIndex={0}
          aria-label="Drag to reorder column"
        >
          <GripVertical className="w-3 h-3" />
        </div>
      )}

      <div
        className={`flex items-center gap-1 px-1 py-1 rounded transition-colors flex-1 min-w-0 ${
          canSort ? "cursor-pointer select-none hover:bg-slate-700" : ""
        }`}
        onClick={canSort ? sortHandler : undefined}
        role={canSort ? "button" : undefined}
        tabIndex={canSort ? 0 : undefined}
        aria-label={canSort ? `Sort by ${children}` : undefined}
        aria-sort={
          isSorted === "asc"
            ? "ascending"
            : isSorted === "desc"
              ? "descending"
              : canSort
                ? "none"
                : undefined
        }
        onKeyDown={(e) => {
          if (canSort && sortHandler && (e.key === "Enter" || e.key === " ")) {
            e.preventDefault();
            sortHandler(e);
          }
        }}
      >
        <span className="truncate">{children}</span>
        {canSort && (
          <div className="w-4 h-4 flex items-center justify-center flex-shrink-0">
            {sortIcon}
          </div>
        )}
      </div>
    </div>
  );
};

// Simplified throttle hook
const useThrottledCallback = (
  callback: (...args: any[]) => void,
  delay: number,
) => {
  const timeoutRef = useRef<NodeJS.Timeout>();
  const lastCallTime = useRef(0);

  useEffect(() => {
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, []);

  return useCallback(
    (...args: any[]) => {
      const now = Date.now();

      if (now - lastCallTime.current >= delay) {
        lastCallTime.current = now;
        callback(...args);
      } else {
        if (timeoutRef.current) {
          clearTimeout(timeoutRef.current);
        }

        timeoutRef.current = setTimeout(
          () => {
            lastCallTime.current = Date.now();
            callback(...args);
          },
          delay - (now - lastCallTime.current),
        );
      }
    },
    [callback, delay],
  );
};

const BaseTable = forwardRef<BaseTableRef, BaseTableProps<any>>(
  (
    {
      table,
      onScroll,
      headerClassName = "bg-slate-800",
      containerClassName = "",
      rowHeight = TABLE_CONSTANTS.ROW_HEIGHT,
      renderFooter,
      emptyStateMessage = "No data available",
      loadingState = false,
    },
    ref,
  ) => {
    const [containerHeight, setContainerHeight] = useState(
      TABLE_CONSTANTS.CONTAINER_HEIGHT,
    );
    const parentRef = useRef<HTMLDivElement>(null);

    // Throttled scroll handler
    const throttledOnScroll = useThrottledCallback(
      useCallback((scrollTop: number) => onScroll?.(scrollTop), [onScroll]),
      TABLE_CONSTANTS.SCROLL_THROTTLE_MS,
    );

    // Update container height on mount and resize
    useEffect(() => {
      const updateHeight = () => {
        if (typeof window !== "undefined") {
          const newHeight = Math.max(
            TABLE_CONSTANTS.CONTAINER_HEIGHT,
            window.innerHeight * TABLE_CONSTANTS.VIEWPORT_HEIGHT_RATIO -
              TABLE_CONSTANTS.HEADER_OFFSET,
          );
          setContainerHeight(newHeight);
        }
      };

      updateHeight();

      if (typeof window !== "undefined") {
        window.addEventListener("resize", updateHeight);
        return () => window.removeEventListener("resize", updateHeight);
      }
    }, []);

    useImperativeHandle(
      ref,
      () => ({
        scrollToOffset: (offset: number) => {
          if (parentRef.current) {
            parentRef.current.scrollTop = offset;
          }
        },
      }),
      [],
    );

    // Handle scroll events with throttling
    useEffect(() => {
      if (!onScroll) return;

      const handleScroll = () => {
        if (parentRef.current) {
          throttledOnScroll(parentRef.current.scrollTop);
        }
      };

      const element = parentRef.current;
      if (element) {
        element.addEventListener("scroll", handleScroll, { passive: true });
        return () => element.removeEventListener("scroll", handleScroll);
      }
    }, [throttledOnScroll, onScroll]);

    // Memoize expensive calculations
    const tableData = useMemo(() => {
      const rowModel = table.getRowModel();
      const headers = table.getHeaderGroups();
      const footers = table.getFooterGroups();

      // Use TanStack's built-in total size calculation
      const width = table.getTotalSize();

      return {
        rows: rowModel.rows,
        headerGroups: headers,
        footerGroups: footers,
        totalWidth: width,
      };
    }, [table]);

    const renderEmptyState = useCallback(
      () => (
        <div className="flex items-center justify-center h-32 text-gray-500">
          <p>{emptyStateMessage}</p>
        </div>
      ),
      [emptyStateMessage],
    );

    const renderLoadingState = useCallback(
      () => (
        <div className="flex items-center justify-center h-32">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-slate-600"></div>
        </div>
      ),
      [],
    );

    return (
      <div className={`flex flex-col h-full ${containerClassName}`}>
        <div className="flex-1 overflow-hidden">
          <div className="h-full flex flex-col">
            {/* Fixed Header */}
            <div
              className={`sticky top-0 z-10 border-b border-gray-200 ${headerClassName}`}
              style={{ width: tableData.totalWidth }}
            >
              {tableData.headerGroups.map((headerGroup) => (
                <div key={headerGroup.id} className="flex">
                  {headerGroup.headers.map((header) => {
                    const resizeHandler = header.getResizeHandler();

                    return (
                      <div
                        key={header.id}
                        className="text-white font-semibold px-1 py-2 border-r border-slate-700 relative"
                        style={{
                          width: header.getSize(),
                          minWidth: header.getSize(),
                        }}
                      >
                        {header.isPlaceholder ? null : (
                          <>
                            {flexRender(
                              header.column.columnDef.header,
                              header.getContext(),
                            )}
                            {/* Column resizer */}
                            {header.column.getCanResize() && (
                              <div
                                className={`absolute right-0 top-0 h-full w-1 cursor-col-resize hover:bg-slate-500 transition-colors ${
                                  header.column.getIsResizing()
                                    ? "bg-slate-400 opacity-100"
                                    : "bg-slate-600 opacity-0 hover:opacity-100"
                                }`}
                                onMouseDown={resizeHandler}
                                onTouchStart={resizeHandler}
                                role="separator"
                                aria-label={`Resize column ${header.column.id}`}
                                tabIndex={0}
                                onKeyDown={(e) => {
                                  if (e.key === "Enter" || e.key === " ") {
                                    e.preventDefault();
                                    // Focus-based resizing could be implemented here
                                  }
                                }}
                                style={{
                                  transform: header.column.getIsResizing()
                                    ? "scaleX(2)"
                                    : "scaleX(1)",
                                }}
                              />
                            )}
                          </>
                        )}
                      </div>
                    );
                  })}
                </div>
              ))}
            </div>

            {/* Scrollable Body */}
            <div className="flex-1">
              <div
                ref={parentRef}
                className="overflow-auto pb-4"
                style={{ height: containerHeight }}
                role="grid"
                aria-label="Data table"
                aria-rowcount={tableData.rows.length}
                aria-colcount={table.getAllColumns().length}
              >
                <div className="w-full" style={{ width: tableData.totalWidth }}>
                  {loadingState
                    ? renderLoadingState()
                    : tableData.rows.length === 0
                      ? renderEmptyState()
                      : tableData.rows.map((row, index) => {
                          const rowClass =
                            index % 2 === 0 ? "bg-white" : "bg-gray-50";

                          return (
                            <div
                              key={row.id}
                              className={`flex border-b border-gray-200 hover:bg-orange-50 transition-colors ${rowClass}`}
                              style={{ height: rowHeight }}
                              role="row"
                              aria-rowindex={index + 2} // +2 because header is row 1
                            >
                              {row.getVisibleCells().map((cell, cellIndex) => (
                                <div
                                  key={cell.id}
                                  className="px-1 py-1 flex items-center border-r border-gray-200 last:border-r-0"
                                  style={{
                                    width: cell.column.getSize(),
                                    minWidth: cell.column.getSize(),
                                  }}
                                  role="gridcell"
                                  aria-colindex={cellIndex + 1}
                                >
                                  {flexRender(
                                    cell.column.columnDef.cell,
                                    cell.getContext(),
                                  )}
                                </div>
                              ))}
                            </div>
                          );
                        })}
                </div>
              </div>
            </div>

            {/* Custom Footer */}
            {renderFooter && (
              <div className="border-t border-gray-200 bg-gray-50">
                {renderFooter()}
              </div>
            )}

            {/* TanStack Table Footer */}
            {tableData.footerGroups.length > 0 && (
              <div
                className="border-t border-gray-200 bg-gray-50"
                style={{ width: tableData.totalWidth }}
              >
                {tableData.footerGroups.map((footerGroup) => (
                  <div key={footerGroup.id} className="flex">
                    {footerGroup.headers.map((header) => (
                      <div
                        key={header.id}
                        className="px-2 py-2 text-sm font-medium text-gray-700 border-r border-gray-200 last:border-r-0"
                        style={{
                          width: header.getSize(),
                          minWidth: header.getSize(),
                        }}
                      >
                        {header.isPlaceholder
                          ? null
                          : flexRender(
                              header.column.columnDef.footer,
                              header.getContext(),
                            )}
                      </div>
                    ))}
                  </div>
                ))}
              </div>
            )}
          </div>
        </div>
      </div>
    );
  },
);

BaseTable.displayName = "BaseTable";

export default BaseTable;
