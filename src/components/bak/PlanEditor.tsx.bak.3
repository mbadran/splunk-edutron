import React, {
  useState,
  useEffect,
  useCallback,
  useMemo,
  useRef,
} from "react";
import Header from "./Header";
import Catalog from "./Catalog";
import Team from "./Team";
import Footer from "./Footer";
import { ConfirmationModal, useConfirmationModal } from "./Utilities";
import { useScrollSync } from "./hooks/scrollSync";
import { Course, PlanState } from "./types";
import {
  DEFAULT_PLAN_TITLE,
  PAGE_TITLE_EDIT,
  DEFAULT_TEAM_NAMES,
} from "./constants";

// Constants
const MAX_HISTORY_SIZE = 50;
const RESIZE_BOUNDS = { min: 30, max: 70 };
const DEFAULT_LEFT_WIDTH = 50;

interface PlanScrollerProps {
  courseCount: number;
  courses: Course[];
  teamMembers: string[];
  selections: Record<string, boolean>;
  onCoursesLoad: (count: number, courses: Course[]) => void;
  onTeamMembersChange: (members: string[]) => void;
  onSelectionsChange: (selections: Record<string, boolean>) => void;
}

const PlanScroller: React.FC<PlanScrollerProps> = React.memo(
  ({
    courseCount,
    courses,
    teamMembers,
    selections,
    onCoursesLoad,
    onTeamMembersChange,
    onSelectionsChange,
  }) => {
    const [isResizing, setIsResizing] = useState(false);
    const [leftWidth, setLeftWidth] = useState(DEFAULT_LEFT_WIDTH);
    const containerRef = useRef<HTMLDivElement>(null);

    const {
      catalogTableRef,
      teamTableRef,
      handleCatalogScroll,
      handleTeamScroll,
    } = useScrollSync();

    // Memoize event handlers to prevent unnecessary re-renders
    const handleMouseMove = useCallback(
      (e: MouseEvent) => {
        if (!isResizing || !containerRef.current) return;

        const containerRect = containerRef.current.getBoundingClientRect();
        const newLeftWidth =
          ((e.clientX - containerRect.left) / containerRect.width) * 100;

        if (
          newLeftWidth >= RESIZE_BOUNDS.min &&
          newLeftWidth <= RESIZE_BOUNDS.max
        ) {
          setLeftWidth(newLeftWidth);
        }
      },
      [isResizing],
    );

    const handleMouseUp = useCallback(() => {
      setIsResizing(false);
    }, []);

    const handleMouseDown = useCallback(() => {
      setIsResizing(true);
    }, []);

    // Stable event handlers for child components
    const handleCoursesLoad = useCallback(
      (count: number, courses: Course[]) => {
        onCoursesLoad(count, courses);
      },
      [onCoursesLoad],
    );

    const handleTeamChange = useCallback(
      (members: string[]) => {
        onTeamMembersChange(members);
      },
      [onTeamMembersChange],
    );

    const handleToggleSelection = useCallback(
      (courseIndex: number, memberIndex: number) => {
        const key = `${courseIndex}-${memberIndex}`;
        onSelectionsChange((prev) => ({
          ...prev,
          [key]: !prev[key],
        }));
      },
      [onSelectionsChange],
    );

    const isSelected = useCallback(
      (courseIndex: number, memberIndex: number) => {
        const key = `${courseIndex}-${memberIndex}`;
        return selections[key] || false;
      },
      [selections],
    );

    useEffect(() => {
      if (isResizing) {
        document.addEventListener("mousemove", handleMouseMove);
        document.addEventListener("mouseup", handleMouseUp);

        return () => {
          document.removeEventListener("mousemove", handleMouseMove);
          document.removeEventListener("mouseup", handleMouseUp);
        };
      }
    }, [isResizing, handleMouseMove, handleMouseUp]);

    return (
      <div
        ref={containerRef}
        className="h-[70vh] training-plan-container flex relative"
      >
        <div
          className="h-full overflow-hidden catalog-scroll-container"
          style={{ width: `${leftWidth}%` }}
        >
          <div className="bg-white h-full">
            <Catalog
              ref={catalogTableRef}
              onCoursesLoad={handleCoursesLoad}
              onScroll={handleCatalogScroll}
            />
          </div>
        </div>

        <div
          className="bg-gradient-to-b from-orange-500 to-pink-500 cursor-col-resize hover:from-orange-600 hover:to-pink-600 transition-colors duration-150 group relative flex-shrink-0 flex items-center justify-center hover:cursor-grab active:cursor-grabbing"
          style={{ width: "10px" }}
          onMouseDown={handleMouseDown}
        >
          <div
            className="bg-orange-500 rounded-md shadow-lg group-hover:bg-orange-600 transition-colors duration-150 flex flex-col items-center justify-center z-10 border border-orange-400 gap-1"
            style={{ width: "14px", height: "32px" }}
          >
            <div className="w-1 h-1 bg-amber-800 rounded-full"></div>
            <div className="w-1 h-1 bg-amber-800 rounded-full"></div>
            <div className="w-1 h-1 bg-amber-800 rounded-full"></div>
          </div>
        </div>

        <div
          className="h-full overflow-hidden team-scroll-container"
          style={{ width: `${100 - leftWidth}%` }}
        >
          <div className="bg-white h-full">
            <Team
              ref={teamTableRef}
              courses={courses}
              courseCount={courseCount}
              teamMembers={teamMembers}
              selections={selections}
              onTeamMembersChange={handleTeamChange}
              onToggleSelection={handleToggleSelection}
              isSelected={isSelected}
              onScroll={handleTeamScroll}
            />
          </div>
        </div>
      </div>
    );
  },
);

PlanScroller.displayName = "PlanScroller";

interface PlanEditorProps {
  onBackToWelcome: () => void;
  hasExistingPlan: boolean;
}

// Utility functions outside component to prevent recreation
const createInitialState = (): PlanState => ({
  title: DEFAULT_PLAN_TITLE,
  courseCount: 0,
  teamMembers: [DEFAULT_TEAM_NAMES[0]],
  selections: {},
});

const statesEqual = (a: PlanState, b: PlanState): boolean => {
  return (
    a.title === b.title &&
    a.courseCount === b.courseCount &&
    JSON.stringify(a.teamMembers) === JSON.stringify(b.teamMembers) &&
    JSON.stringify(a.selections) === JSON.stringify(b.selections)
  );
};

const PlanEditor: React.FC<PlanEditorProps> = ({
  onBackToWelcome,
  hasExistingPlan,
}) => {
  const initialState = useMemo(() => createInitialState(), []);

  const [planTitle, setPlanTitle] = useState(initialState.title);
  const [courseCount, setCourseCount] = useState(initialState.courseCount);
  const [courses, setCourses] = useState<Course[]>([]);
  const [teamMembers, setTeamMembers] = useState(initialState.teamMembers);
  const [selections, setSelections] = useState(initialState.selections);
  const [budget, setBudget] = useState<number | null>(null);
  const [history, setHistory] = useState<PlanState[]>([initialState]);
  const [historyIndex, setHistoryIndex] = useState(0);

  const {
    showConfirmation,
    showConfirmationModal,
    handleConfirmAction,
    handleCancelAction,
    confirmationTitle,
    confirmationMessage,
  } = useConfirmationModal();

  // Memoize current state to prevent unnecessary calculations
  const currentState = useMemo(
    (): PlanState => ({
      title: planTitle,
      courseCount,
      teamMembers,
      selections,
    }),
    [planTitle, courseCount, teamMembers, selections],
  );

  // Memoize hasChanges calculation
  const hasChanges = useMemo(() => {
    return !statesEqual(currentState, initialState);
  }, [currentState, initialState]);

  // Memoize total calculation
  const total = useMemo(() => {
    let calculatedTotal = 0;

    Object.entries(selections).forEach(([key, isSelected]) => {
      if (isSelected) {
        const [courseIndexStr] = key.split("-");
        const courseIndex = parseInt(courseIndexStr, 10);

        if (courses[courseIndex]) {
          const price = courses[courseIndex].Price || 0;
          calculatedTotal += price;
        }
      }
    });

    return calculatedTotal;
  }, [selections, courses]);

  // Stable function to update history
  const updateHistory = useCallback(
    (newState: PlanState) => {
      setHistory((prev) => {
        // Don't add to history if state hasn't changed
        if (
          prev[prev.length - 1] &&
          statesEqual(prev[prev.length - 1], newState)
        ) {
          return prev;
        }

        const newHistory = prev.slice(0, historyIndex + 1);
        newHistory.push(newState);

        // Limit history size
        if (newHistory.length > MAX_HISTORY_SIZE) {
          newHistory.shift();
          return newHistory;
        }

        return newHistory;
      });

      setHistoryIndex((prev) => {
        const newIndex = Math.min(prev + 1, MAX_HISTORY_SIZE - 1);
        return newIndex;
      });
    },
    [historyIndex],
  );

  // Set page title on mount
  useEffect(() => {
    document.title = PAGE_TITLE_EDIT;
  }, []);

  // Handle browser back button
  useEffect(() => {
    const handlePopState = () => {
      if (hasChanges) {
        showConfirmationModal(
          () => onBackToWelcome(),
          "Unsaved Changes!",
          "We recommend downloading your current plan before continuing. Are you sure you want to leave?",
        );
        window.history.pushState({ view: "edit" }, "", "#edit");
      } else {
        onBackToWelcome();
      }
    };

    window.addEventListener("popstate", handlePopState);
    return () => window.removeEventListener("popstate", handlePopState);
  }, [hasChanges, showConfirmationModal, onBackToWelcome]);

  // Stable handlers
  const handleUpdateTitle = useCallback(
    (newTitle: string) => {
      setPlanTitle(newTitle);
      const newState = { ...currentState, title: newTitle };
      updateHistory(newState);
    },
    [currentState, updateHistory],
  );

  const handleDownload = useCallback(() => {
    alert("Coming soon!");
  }, []);

  const handleCoursesLoad = useCallback(
    (count: number, newCourses: Course[]) => {
      setCourseCount(count);
      setCourses(newCourses);
      // Only update history if count actually changed
      if (count !== courseCount) {
        const newState = { ...currentState, courseCount: count };
        updateHistory(newState);
      }
    },
    [courseCount, currentState, updateHistory],
  );

  const handleTeamMembersChange = useCallback(
    (newTeamMembers: string[]) => {
      setTeamMembers(newTeamMembers);
      const newState = { ...currentState, teamMembers: newTeamMembers };
      updateHistory(newState);
    },
    [currentState, updateHistory],
  );

  const handleSelectionsChange = useCallback(
    (newSelections: Record<string, boolean>) => {
      setSelections(newSelections);
      const newState = { ...currentState, selections: newSelections };
      updateHistory(newState);
    },
    [currentState, updateHistory],
  );

  const handleBudgetChange = useCallback((newBudget: number | null) => {
    setBudget(newBudget);
  }, []);

  const handleUndo = useCallback(() => {
    if (historyIndex > 0) {
      const newIndex = historyIndex - 1;
      const state = history[newIndex];
      setHistoryIndex(newIndex);
      setPlanTitle(state.title);
      setCourseCount(state.courseCount);
      setTeamMembers(state.teamMembers);
      setSelections(state.selections);
    }
  }, [historyIndex, history]);

  const handleRedo = useCallback(() => {
    if (historyIndex < history.length - 1) {
      const newIndex = historyIndex + 1;
      const state = history[newIndex];
      setHistoryIndex(newIndex);
      setPlanTitle(state.title);
      setCourseCount(state.courseCount);
      setTeamMembers(state.teamMembers);
      setSelections(state.selections);
    }
  }, [historyIndex, history]);

  const canUndo = historyIndex > 0;
  const canRedo = historyIndex < history.length - 1;

  const handleBackToWelcome = useCallback(() => {
    if (hasChanges) {
      showConfirmationModal(
        () => onBackToWelcome(),
        "Unsaved Changes!",
        "We recommend downloading your current plan before continuing. Are you sure you want to leave?",
      );
    } else {
      onBackToWelcome();
    }
  }, [hasChanges, showConfirmationModal, onBackToWelcome]);

  return (
    <div className="min-h-screen bg-gray-50 flex flex-col">
      <Header
        onBackToWelcome={handleBackToWelcome}
        planTitle={planTitle}
        onUpdateTitle={handleUpdateTitle}
        onUndo={handleUndo}
        onRedo={handleRedo}
        onDownload={handleDownload}
        canUndo={canUndo}
        canRedo={canRedo}
        total={total}
        onBudgetChange={handleBudgetChange}
      />

      <PlanScroller
        courseCount={courseCount}
        courses={courses}
        teamMembers={teamMembers}
        selections={selections}
        onCoursesLoad={handleCoursesLoad}
        onTeamMembersChange={handleTeamMembersChange}
        onSelectionsChange={handleSelectionsChange}
      />

      <div className="mt-16">
        <Footer />
      </div>

      <ConfirmationModal
        isOpen={showConfirmation}
        onClose={handleCancelAction}
        onConfirm={handleConfirmAction}
        title={confirmationTitle}
        message={confirmationMessage}
      />
    </div>
  );
};

export default PlanEditor;
