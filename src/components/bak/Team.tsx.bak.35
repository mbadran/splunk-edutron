import React, {
  useState,
  forwardRef,
  useImperativeHandle,
  useCallback,
  useMemo,
  useRef,
} from "react";
import { Plus, Edit, Check, X, Trash2 } from "lucide-react";
import {
  useReactTable,
  getCoreRowModel,
  createColumnHelper,
  ColumnDef,
} from "@tanstack/react-table";
import BaseTable, {
  BaseTableRef,
  TABLE_CONSTANTS,
  SortableHeader,
} from "./common/BaseTable";
import { Course } from "./types";
import { DEFAULT_TEAM_NAMES } from "./constants";
import TeamInsights from "./TeamInsights";

interface TeamProps {
  courses: Course[];
  courseCount: number;
  teamMembers: string[];
  selections: Record<string, boolean>;
  onTeamMembersChange: (members: string[]) => void;
  onToggleSelection: (courseIndex: number, memberIndex: number) => void;
  isSelected: (courseIndex: number, memberIndex: number) => boolean;
  onScroll?: (scrollOffset: number) => void;
}

interface SelectionCellProps {
  courseIndex: number;
  memberIndex: number;
  isSelected: boolean;
  onToggle: () => void;
  courseName: string;
  memberName: string;
}

interface TeamMemberHeaderProps {
  member: string;
  index: number;
  onEdit: () => void;
  onDelete: () => void;
  isEditing: boolean;
  editValue: string;
  onEditChange: (value: string) => void;
  onSave: () => void;
  onCancel: () => void;
  totalMembers: number;
}

interface TeamRef {
  scrollToOffset: (offset: number) => void;
}

const MAX_TEAM_MEMBERS = 20;
const MEMBER_COLUMN_WIDTH = TABLE_CONSTANTS.COLUMN_WIDTH.MEDIUM;

const SelectionCell: React.FC<SelectionCellProps> = React.memo(
  ({
    courseIndex,
    memberIndex,
    isSelected,
    onToggle,
    courseName,
    memberName,
  }) => {
    return (
      <div className="h-12 flex items-center justify-center px-2">
        {isSelected ? (
          <button
            onClick={onToggle}
            className="w-full h-8 flex items-center justify-center text-lg font-bold transition-all duration-200 rounded cursor-pointer bg-emerald-200 text-white hover:bg-emerald-300"
            title={`Remove '${courseName}' for ${memberName}`}
            aria-label={`Remove '${courseName}' for ${memberName}`}
          >
            ‚óè
          </button>
        ) : (
          <button
            onClick={onToggle}
            className="w-full h-8 flex items-center justify-center transition-all duration-200 rounded cursor-pointer hover:bg-orange-100"
            title={`Add '${courseName}' for ${memberName}`}
            aria-label={`Add '${courseName}' for ${memberName}`}
          >
            {/* Completely blank when not selected */}
          </button>
        )}
      </div>
    );
  },
);

SelectionCell.displayName = "SelectionCell";

const TeamMemberHeader: React.FC<TeamMemberHeaderProps> = React.memo(
  ({
    member,
    index,
    onEdit,
    onDelete,
    isEditing,
    editValue,
    onEditChange,
    onSave,
    onCancel,
    totalMembers,
  }) => {
    if (isEditing) {
      return (
        <div className="flex items-center justify-center gap-1 w-full h-full px-1">
          <input
            type="text"
            value={editValue}
            onChange={(e) => onEditChange(e.target.value)}
            onKeyDown={(e) => {
              if (e.key === "Enter") onSave();
              if (e.key === "Escape") onCancel();
            }}
            className="flex-1 h-6 px-1 text-xs text-white bg-transparent rounded border-none outline-none text-center border-b-2 border-dashed border-white/60"
            autoFocus
            maxLength={30}
            onFocus={(e) => e.target.select()}
          />
          <div className="flex gap-1">
            <button
              onClick={onSave}
              className="text-green-300 hover:text-green-100 p-0.5 rounded"
              title="Save"
              aria-label="Save changes"
            >
              <Check className="w-3 h-3" />
            </button>
            <button
              onClick={onCancel}
              className="text-red-300 hover:text-red-100 p-0.5 rounded"
              title="Cancel"
              aria-label="Cancel editing"
            >
              <X className="w-3 h-3" />
            </button>
          </div>
        </div>
      );
    }

    return (
      <div className="flex items-center justify-between w-full h-full px-1">
        {/* Member name with TanStack's truncation handling */}
        <div
          className="flex-1 text-center cursor-pointer select-none hover:bg-slate-700/50 rounded px-1 py-0.5 transition-colors min-w-0"
          onClick={onEdit}
          title={member}
        >
          <span className="text-sm font-semibold block truncate">{member}</span>
        </div>

        {/* Action buttons */}
        <div className="flex gap-0.5 opacity-60 hover:opacity-100 transition-opacity ml-1">
          <button
            onClick={(e) => {
              e.stopPropagation();
              onEdit();
            }}
            className="p-0.5 hover:bg-slate-600 rounded transition-colors"
            title="Edit name"
            aria-label={`Edit ${member} name`}
          >
            <Edit className="w-3 h-3" />
          </button>

          {totalMembers > 1 && (
            <button
              onClick={(e) => {
                e.stopPropagation();
                onDelete();
              }}
              className="p-0.5 hover:bg-slate-600 hover:text-red-300 rounded transition-colors"
              title="Delete member"
              aria-label={`Delete ${member}`}
            >
              <Trash2 className="w-3 h-3" />
            </button>
          )}
        </div>
      </div>
    );
  },
);

TeamMemberHeader.displayName = "TeamMemberHeader";

const Team = forwardRef<TeamRef, TeamProps>(
  (
    {
      courses = [],
      courseCount,
      teamMembers = [],
      selections = {},
      onTeamMembersChange,
      onToggleSelection,
      isSelected,
      onScroll,
    },
    ref,
  ) => {
    console.log('üîß Team render:', {
      coursesLength: courses.length,
      courseCount,
      teamMembersLength: teamMembers.length,
      selectionsKeys: Object.keys(selections).length,
      timestamp: Date.now()
    });

    const [editingMember, setEditingMember] = useState<number | null>(null);
    const [editValue, setEditValue] = useState("");

    const baseTableRef = useRef<BaseTableRef>(null);
    const renderCountRef = useRef(0);
    renderCountRef.current++;

    console.log('üîß Team render count:', renderCountRef.current);

    useImperativeHandle(ref, () => ({
      scrollToOffset: (offset: number) => {
        baseTableRef.current?.scrollToOffset(offset);
      },
    }));

    // FIXED: Stable callbacks that don't recreate on every render
    const handleDeleteTeamMember = useCallback(
      (index: number) => {
        console.log('üîß Team handleDeleteTeamMember:', index);
        if (teamMembers.length <= 1) return;

        const updatedMembers = teamMembers.filter((_, i) => i !== index);
        onTeamMembersChange?.(updatedMembers);

        if (editingMember === index) {
          setEditingMember(null);
          setEditValue("");
        } else if (editingMember !== null && editingMember > index) {
          setEditingMember(editingMember - 1);
        }
      },
      [teamMembers, onTeamMembersChange, editingMember],
    );

    const handleAddTeamMember = useCallback(
      (e: React.MouseEvent) => {
        e.preventDefault();
        e.stopPropagation();
        console.log('üîß Team handleAddTeamMember');

        if (teamMembers.length >= MAX_TEAM_MEMBERS) return;
        if (!onTeamMembersChange) return;

        const newMemberName =
          DEFAULT_TEAM_NAMES[teamMembers.length] ||
          `Team Member ${teamMembers.length + 1}`;
        onTeamMembersChange([...teamMembers, newMemberName]);
      },
      [teamMembers, onTeamMembersChange],
    );

    const handleUpdateTeamMember = useCallback(
      (index: number, newName: string) => {
        console.log('üîß Team handleUpdateTeamMember:', index, newName);
        const trimmedName = newName.trim();
        if (!trimmedName || !onTeamMembersChange) return;

        if (
          teamMembers.some(
            (name, i) =>
              i !== index && name.toLowerCase() === trimmedName.toLowerCase(),
          )
        ) {
          return;
        }

        const updatedMembers = [...teamMembers];
        updatedMembers[index] = trimmedName;
        onTeamMembersChange(updatedMembers);
      },
      [teamMembers, onTeamMembersChange],
    );

    // FIXED: These callbacks are now stable
    const startEditing = useCallback(
      (index: number) => {
        console.log('üîß Team startEditing:', index);
        setEditingMember(index);
        setEditValue(teamMembers[index]);
      },
      [teamMembers],
    );

    const saveEdit = useCallback(() => {
      console.log('üîß Team saveEdit:', editingMember, editValue);
      if (editValue.trim() && editingMember !== null) {
        handleUpdateTeamMember(editingMember, editValue.trim());
      }
      setEditingMember(null);
      setEditValue("");
    }, [editValue, editingMember, handleUpdateTeamMember]);

    const cancelEdit = useCallback(() => {
      console.log('üîß Team cancelEdit');
      setEditingMember(null);
      setEditValue("");
    }, []);

    const canAddMember = teamMembers.length < MAX_TEAM_MEMBERS;

    const columnHelper = createColumnHelper<Course>();

    // FIXED: Create stable column creation functions
    const createMemberColumn = useCallback(
      (member: string, memberIndex: number) => {
        console.log('üîß Team createMemberColumn:', member, memberIndex);
        return columnHelper.display({
          id: `member-${memberIndex}`,
          header: ({ column }) => (
            <SortableHeader column={column} showDragHandle={false}>
              <TeamMemberHeader
                member={member}
                index={memberIndex}
                totalMembers={teamMembers.length}
                isEditing={editingMember === memberIndex}
                editValue={editValue}
                onEdit={() => startEditing(memberIndex)}
                onDelete={() => handleDeleteTeamMember(memberIndex)}
                onEditChange={setEditValue}
                onSave={saveEdit}
                onCancel={cancelEdit}
              />
            </SortableHeader>
          ),
          cell: ({ row }) => (
            <SelectionCell
              courseIndex={row.index}
              memberIndex={memberIndex}
              isSelected={isSelected?.(row.index, memberIndex) || false}
              onToggle={() => onToggleSelection?.(row.index, memberIndex)}
              courseName={row.original.Name}
              memberName={member}
            />
          ),
          size: MEMBER_COLUMN_WIDTH,
          minSize: TABLE_CONSTANTS.COLUMN_LIMITS.MIN_MEDIUM,
          maxSize: TABLE_CONSTANTS.COLUMN_LIMITS.MAX_MEDIUM,
          enableResizing: true,
        });
      },
      [
        columnHelper,
        teamMembers.length,
        editingMember,
        editValue,
        startEditing,
        handleDeleteTeamMember,
        saveEdit,
        cancelEdit,
        isSelected,
        onToggleSelection,
      ],
    );

    const createAddButtonColumn = useCallback(() => {
      console.log('üîß Team createAddButtonColumn');
      return columnHelper.display({
        id: "add-member",
        header: ({ column }) => (
          <SortableHeader column={column} showDragHandle={false}>
            <div className="w-full h-full flex items-center justify-center">
              <button
                onClick={handleAddTeamMember}
                disabled={!canAddMember}
                className={`w-8 h-8 bg-transparent border-none text-white transition-colors rounded flex items-center justify-center font-semibold ${
                  canAddMember
                    ? "hover:bg-slate-700 cursor-pointer"
                    : "opacity-50 cursor-not-allowed"
                }`}
                title={
                  canAddMember
                    ? "Add team member"
                    : `Maximum ${MAX_TEAM_MEMBERS} members allowed`
                }
                aria-label={
                  canAddMember
                    ? "Add new team member"
                    : `Maximum ${MAX_TEAM_MEMBERS} members allowed`
                }
              >
                <Plus className="w-5 h-5" />
              </button>
            </div>
          </SortableHeader>
        ),
        cell: () => <div className="h-12"></div>,
        size: MEMBER_COLUMN_WIDTH,
        minSize: TABLE_CONSTANTS.COLUMN_LIMITS.MIN_MEDIUM,
        maxSize: TABLE_CONSTANTS.COLUMN_LIMITS.MAX_MEDIUM,
        enableResizing: true,
      });
    }, [columnHelper, canAddMember, handleAddTeamMember]);

    // FIXED: Stable columns with reduced dependencies
    const columns: ColumnDef<Course, any>[] = useMemo(() => {
      console.log('üîß Team columns useMemo recalculating');
      const memberColumns = teamMembers.map((member, memberIndex) =>
        createMemberColumn(member, memberIndex)
      );
      const addButtonColumn = createAddButtonColumn();
      return [...memberColumns, addButtonColumn];
    }, [
      teamMembers,
      createMemberColumn,
      createAddButtonColumn,
    ]);

    const table = useReactTable({
      data: courses,
      columns,
      getCoreRowModel: getCoreRowModel(),
      enableColumnResizing: true,
      columnResizeMode: "onChange",
    });

    const renderFooter = useCallback(() => {
      console.log('üîß Team renderFooter');
      return <TeamInsights />;
    }, []);

    const emptyStateMessage = useMemo(() => {
      if (courses.length === 0) {
        return "No courses loaded. Please ensure courses are available from the Catalog.";
      }
      return "No courses available for team assignment";
    }, [courses.length]);

    console.log('üîß Team about to render BaseTable');

    return (
      <BaseTable
        ref={baseTableRef}
        table={table}
        onScroll={onScroll}
        headerClassName="bg-slate-800"
        rowHeight={TABLE_CONSTANTS.ROW_HEIGHT}
        renderFooter={renderFooter}
        emptyStateMessage={emptyStateMessage}
        columnResizeMode="onChange"
      />
    );
  },
);

Team.displayName = "Team";

export default Team;