import React from "react";
import {
  useReactTable,
  getCoreRowModel,
  getSortedRowModel,
  createColumnHelper,
  ColumnDef,
} from "@tanstack/react-table";
import { Plus, Edit, Check, X, Trash2 } from "lucide-react";
import { useAtom } from "jotai";
import { atomWithStorage } from "jotai/utils";
import BaseTable, { SortableHeader } from "@/components/common/BaseTable";
import TeamBase from "./TeamBase";
import { Person } from "@/types/types";
import { DEFAULT_TABLE } from "@/utils/constants";

interface TeamTableProps {
  data?: any[]; // Generic data that team members will be assigned to
  teamMembers?: string[]; // Optional initial team members
  onTeamChange?: (
    teamMembers: string[],
    assignments: Record<string, boolean>,
  ) => void;
  onScroll?: (scrollTop: number) => void;
  maxMembers?: number;
  defaultMemberNames?: string[];
}

interface SelectionCellProps {
  dataIndex: number;
  memberIndex: number;
  isSelected: boolean;
  onToggle: () => void;
  dataName: string;
  memberName: string;
}

interface TeamMemberHeaderProps {
  member: string;
  index: number;
  onEdit: () => void;
  onDelete: () => void;
  isEditing: boolean;
  editValue: string;
  onEditChange: (value: string) => void;
  onSave: () => void;
  onCancel: () => void;
  totalMembers: number;
}

// Jotai atoms for state management
const tableSortingAtom = atomWithStorage("team-table-sorting", []);
const teamMembersAtom = atomWithStorage("team-table-members", [] as string[]);
const teamAssignmentsAtom = atomWithStorage(
  "team-table-assignments",
  {} as Record<string, boolean>,
);
const editingMemberAtom = atomWithStorage(
  "team-table-editing",
  null as number | null,
);

const MAX_TEAM_MEMBERS = 20;
const MEMBER_COLUMN_WIDTH = DEFAULT_TABLE.COLUMN_WIDTH.MEDIUM;

const SelectionCell: React.FC<SelectionCellProps> = React.memo(
  ({ dataIndex, memberIndex, isSelected, onToggle, dataName, memberName }) => {
    return (
      <div
        id={`team-selection-${dataIndex}-${memberIndex}`}
        className="h-12 flex items-center justify-center px-2"
      >
        {isSelected ? (
          <button
            onClick={onToggle}
            className="w-full h-8 flex items-center justify-center text-lg font-bold transition-all duration-200 rounded cursor-pointer bg-emerald-200 text-white hover:bg-emerald-300"
            title={`Remove '${dataName}' for ${memberName}`}
            aria-label={`Remove '${dataName}' for ${memberName}`}
          >
            ‚óè
          </button>
        ) : (
          <button
            onClick={onToggle}
            className="w-full h-8 flex items-center justify-center transition-all duration-200 rounded cursor-pointer hover:bg-orange-100"
            title={`Add '${dataName}' for ${memberName}`}
            aria-label={`Add '${dataName}' for ${memberName}`}
          >
            {/* Blank when not selected */}
          </button>
        )}
      </div>
    );
  },
);

SelectionCell.displayName = "SelectionCell";

const TeamMemberHeader: React.FC<TeamMemberHeaderProps> = React.memo(
  ({
    member,
    index,
    onEdit,
    onDelete,
    isEditing,
    editValue,
    onEditChange,
    onSave,
    onCancel,
    totalMembers,
  }) => {
    if (isEditing) {
      return (
        <div
          id={`team-header-editing-${index}`}
          className="flex items-center justify-center gap-1 w-full h-full px-1"
        >
          <input
            type="text"
            value={editValue}
            onChange={(e) => onEditChange(e.target.value)}
            onKeyDown={(e) => {
              if (e.key === "Enter") onSave();
              if (e.key === "Escape") onCancel();
            }}
            className="flex-1 h-6 px-1 text-xs text-white bg-transparent rounded border-none outline-none text-center border-b-2 border-dashed border-white/60"
            autoFocus
            maxLength={30}
            onFocus={(e) => e.target.select()}
          />
          <div className="flex gap-1">
            <button
              onClick={onSave}
              className="text-green-300 hover:text-green-100 p-0.5 rounded"
              title="Save"
              aria-label="Save changes"
            >
              <Check className="w-3 h-3" />
            </button>
            <button
              onClick={onCancel}
              className="text-red-300 hover:text-red-100 p-0.5 rounded"
              title="Cancel"
              aria-label="Cancel editing"
            >
              <X className="w-3 h-3" />
            </button>
          </div>
        </div>
      );
    }

    return (
      <div
        id={`team-header-${index}`}
        className="flex items-center justify-between w-full h-full px-1"
      >
        <div
          className="flex-1 text-center cursor-pointer select-none hover:bg-slate-700/50 rounded px-1 py-0.5 transition-colors min-w-0"
          onClick={onEdit}
          title={member}
        >
          <span className="text-sm font-semibold block truncate">{member}</span>
        </div>

        <div className="flex gap-0.5 opacity-60 hover:opacity-100 transition-opacity ml-1">
          <button
            onClick={(e) => {
              e.stopPropagation();
              onEdit();
            }}
            className="p-0.5 hover:bg-slate-600 rounded transition-colors"
            title="Edit name"
            aria-label={`Edit ${member} name`}
          >
            <Edit className="w-3 h-3" />
          </button>

          {totalMembers > 1 && (
            <button
              onClick={(e) => {
                e.stopPropagation();
                onDelete();
              }}
              className="p-0.5 hover:bg-slate-600 hover:text-red-300 rounded transition-colors"
              title="Delete member"
              aria-label={`Delete ${member}`}
            >
              <Trash2 className="w-3 h-3" />
            </button>
          )}
        </div>
      </div>
    );
  },
);

TeamMemberHeader.displayName = "TeamMemberHeader";

// Inner component that handles the team table logic
const TeamTableInner: React.FC<{
  data: any[];
  teamMembers?: string[];
  onTeamChange?: (
    teamMembers: string[],
    assignments: Record<string, boolean>,
  ) => void;
  onScroll?: (scrollTop: number) => void;
  maxMembers?: number;
  defaultMemberNames?: string[];
  isLoading: boolean;
  error: unknown;
}> = ({
  data = [],
  teamMembers: initialTeamMembers,
  onTeamChange,
  onScroll,
  maxMembers = MAX_TEAM_MEMBERS,
  defaultMemberNames = [],
  isLoading,
  error,
}) => {
  const [sorting, setSorting] = useAtom(tableSortingAtom);
  const [teamMembers, setTeamMembers] = useAtom(teamMembersAtom);
  const [assignments, setAssignments] = useAtom(teamAssignmentsAtom);
  const [editingMember, setEditingMember] = useAtom(editingMemberAtom);
  const [editValue, setEditValue] = React.useState("");

  // Initialize team members if provided or use defaults
  React.useEffect(() => {
    if (initialTeamMembers && initialTeamMembers.length > 0) {
      setTeamMembers(initialTeamMembers);
    } else if (teamMembers.length === 0 && defaultMemberNames.length > 0) {
      setTeamMembers([defaultMemberNames[0] || "Team Member 1"]);
    } else if (teamMembers.length === 0) {
      setTeamMembers(["Team Member 1"]);
    }
  }, [
    initialTeamMembers,
    defaultMemberNames,
    teamMembers.length,
    setTeamMembers,
  ]);

  // Notify parent of team changes
  React.useEffect(() => {
    if (onTeamChange) {
      onTeamChange(teamMembers, assignments);
    }
  }, [teamMembers, assignments, onTeamChange]);

  const columnHelper = createColumnHelper<any>();

  // Selection handlers
  const isSelected = React.useCallback(
    (dataIndex: number, memberIndex: number) => {
      const key = `${dataIndex}-${memberIndex}`;
      return assignments[key] || false;
    },
    [assignments],
  );

  const toggleSelection = React.useCallback(
    (dataIndex: number, memberIndex: number) => {
      const key = `${dataIndex}-${memberIndex}`;
      setAssignments((prev) => ({
        ...prev,
        [key]: !prev[key],
      }));
    },
    [setAssignments],
  );

  // Team member management
  const handleAddTeamMember = React.useCallback(() => {
    if (teamMembers.length >= maxMembers) return;

    const newMemberName =
      defaultMemberNames[teamMembers.length] ||
      `Team Member ${teamMembers.length + 1}`;

    setTeamMembers((prev) => [...prev, newMemberName]);
  }, [teamMembers.length, maxMembers, defaultMemberNames, setTeamMembers]);

  const handleDeleteTeamMember = React.useCallback(
    (index: number) => {
      if (teamMembers.length <= 1) return;

      setTeamMembers((prev) => prev.filter((_, i) => i !== index));

      // Clean up assignments for deleted member
      setAssignments((prev) => {
        const newAssignments = { ...prev };
        Object.keys(newAssignments).forEach((key) => {
          const [, memberIdx] = key.split("-");
          if (parseInt(memberIdx) === index) {
            delete newAssignments[key];
          } else if (parseInt(memberIdx) > index) {
            // Adjust indices for members after deleted one
            const [dataIdx] = key.split("-");
            const newKey = `${dataIdx}-${parseInt(memberIdx) - 1}`;
            newAssignments[newKey] = newAssignments[key];
            delete newAssignments[key];
          }
        });
        return newAssignments;
      });

      if (editingMember === index) {
        setEditingMember(null);
        setEditValue("");
      } else if (editingMember !== null && editingMember > index) {
        setEditingMember(editingMember - 1);
      }
    },
    [
      teamMembers.length,
      editingMember,
      setTeamMembers,
      setAssignments,
      setEditingMember,
    ],
  );

  const handleUpdateTeamMember = React.useCallback(
    (index: number, newName: string) => {
      const trimmedName = newName.trim();
      if (!trimmedName) return;

      if (
        teamMembers.some(
          (name, i) =>
            i !== index && name.toLowerCase() === trimmedName.toLowerCase(),
        )
      ) {
        return;
      }

      setTeamMembers((prev) => {
        const updated = [...prev];
        updated[index] = trimmedName;
        return updated;
      });
    },
    [teamMembers, setTeamMembers],
  );

  // Editing functions
  const startEditing = React.useCallback(
    (index: number) => {
      setEditingMember(index);
      setEditValue(teamMembers[index]);
    },
    [teamMembers, setEditingMember],
  );

  const saveEdit = React.useCallback(() => {
    if (editValue.trim() && editingMember !== null) {
      handleUpdateTeamMember(editingMember, editValue.trim());
    }
    setEditingMember(null);
    setEditValue("");
  }, [editValue, editingMember, handleUpdateTeamMember, setEditingMember]);

  const cancelEdit = React.useCallback(() => {
    setEditingMember(null);
    setEditValue("");
  }, [setEditingMember]);

  // Create columns dynamically based on team members
  const columns: ColumnDef<any, any>[] = React.useMemo(() => {
    const memberColumns = teamMembers.map((member, memberIndex) =>
      columnHelper.display({
        id: `member-${memberIndex}`,
        header: ({ column }) => (
          <SortableHeader column={column} showDragHandle={false}>
            <TeamMemberHeader
              member={member}
              index={memberIndex}
              totalMembers={teamMembers.length}
              isEditing={editingMember === memberIndex}
              editValue={editValue}
              onEdit={() => startEditing(memberIndex)}
              onDelete={() => handleDeleteTeamMember(memberIndex)}
              onEditChange={setEditValue}
              onSave={saveEdit}
              onCancel={cancelEdit}
            />
          </SortableHeader>
        ),
        cell: ({ row }) => (
          <SelectionCell
            dataIndex={row.index}
            memberIndex={memberIndex}
            isSelected={isSelected(row.index, memberIndex)}
            onToggle={() => toggleSelection(row.index, memberIndex)}
            dataName={
              row.original.Name || row.original.name || `Item ${row.index + 1}`
            }
            memberName={member}
          />
        ),
        size: MEMBER_COLUMN_WIDTH,
        minSize: DEFAULT_TABLE.COLUMN_LIMITS.MIN_MEDIUM,
        maxSize: DEFAULT_TABLE.COLUMN_LIMITS.MAX_MEDIUM,
        enableResizing: true,
      }),
    );

    const addButtonColumn = columnHelper.display({
      id: "add-member",
      header: ({ column }) => (
        <SortableHeader column={column} showDragHandle={false}>
          <div
            id="team-add-member-header"
            className="w-full h-full flex items-center justify-center"
          >
            <button
              onClick={handleAddTeamMember}
              disabled={teamMembers.length >= maxMembers}
              className={`w-8 h-8 bg-transparent border-none text-white transition-colors rounded flex items-center justify-center font-semibold ${
                teamMembers.length < maxMembers
                  ? "hover:bg-slate-700 cursor-pointer"
                  : "opacity-50 cursor-not-allowed"
              }`}
              title={
                teamMembers.length < maxMembers
                  ? "Add team member"
                  : `Maximum ${maxMembers} members allowed`
              }
              aria-label={
                teamMembers.length < maxMembers
                  ? "Add new team member"
                  : `Maximum ${maxMembers} members allowed`
              }
            >
              <Plus className="w-5 h-5" />
            </button>
          </div>
        </SortableHeader>
      ),
      cell: () => <div className="h-12"></div>,
      size: MEMBER_COLUMN_WIDTH,
      minSize: DEFAULT_TABLE.COLUMN_LIMITS.MIN_MEDIUM,
      maxSize: DEFAULT_TABLE.COLUMN_LIMITS.MAX_MEDIUM,
      enableResizing: true,
    });

    return [...memberColumns, addButtonColumn];
  }, [
    teamMembers,
    editingMember,
    editValue,
    columnHelper,
    startEditing,
    handleDeleteTeamMember,
    saveEdit,
    cancelEdit,
    isSelected,
    toggleSelection,
    handleAddTeamMember,
    maxMembers,
  ]);

  const table = useReactTable({
    data: data || [],
    columns,
    getCoreRowModel: getCoreRowModel(),
    getSortedRowModel: getSortedRowModel(),
    state: {
      sorting,
    },
    onSortingChange: setSorting,
    enableColumnResizing: true,
    columnResizeMode: "onChange",
    enableSorting: !isLoading && !error,
  });

  // Handle loading and error states
  if (isLoading || error) {
    return null; // TeamBase handles loading and error states
  }

  const emptyStateMessage = React.useMemo(() => {
    if (data.length === 0) {
      return "No data available for team assignment";
    }
    return "No items available for team assignment";
  }, [data.length]);

  return (
    <div id="team-table" className="h-full">
      <BaseTable
        table={table}
        onScroll={onScroll}
        headerClassName="bg-slate-800"
        rowHeight={48}
        emptyStateMessage={emptyStateMessage}
        loadingState={false}
      />
    </div>
  );
};

const TeamTable: React.FC<TeamTableProps> = ({
  data = [],
  teamMembers,
  onTeamChange,
  onScroll,
  maxMembers = MAX_TEAM_MEMBERS,
  defaultMemberNames = [],
}) => {
  return (
    <div id="team-table-container" className="h-full">
      <TeamBase>
        {({ isLoading, error }) => (
          <TeamTableInner
            data={data}
            teamMembers={teamMembers}
            onTeamChange={onTeamChange}
            onScroll={onScroll}
            maxMembers={maxMembers}
            defaultMemberNames={defaultMemberNames}
            isLoading={isLoading}
            error={error}
          />
        )}
      </TeamBase>
    </div>
  );
};

export default TeamTable;
