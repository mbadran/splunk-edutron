import React, { useEffect } from "react";
import { Undo, Redo, Settings } from "lucide-react";
import { useAtom } from "jotai";
import { atomWithStorage } from "jotai/utils";
import { setStatusAtom } from "@/atoms/globalAtoms";
import {
  tableHistoryStateAtom,
  canUndoTableAtom,
  canRedoTableAtom,
  createTableSnapshot,
} from "@/atoms/table/tableHistoryAtom";

// Export atoms for CatalogTable to use - using camelCase naming convention
export const catalogTableSortingAtom = atomWithStorage("catalogTableSorting", []);
export const catalogTableFiltersAtom = atomWithStorage("catalogTableFilters", []);
export const catalogTableColumnOrderAtom = atomWithStorage("catalogTableColumnOrder", []);

interface CatalogActionsProps {
  tableId?: string;
}

const CatalogActions = ({ tableId = "catalog" }: CatalogActionsProps) => {
  const [, setStatus] = useAtom(setStatusAtom);
  const [canUndo] = useAtom(canUndoTableAtom);
  const [canRedo] = useAtom(canRedoTableAtom);
  const [tableHistory, setTableHistory] = useAtom(tableHistoryStateAtom);

  const [tableSorting, setTableSorting] = useAtom(catalogTableSortingAtom);
  const [tableFilters, setTableFilters] = useAtom(catalogTableFiltersAtom);
  const [tableColumnOrder, setTableColumnOrder] = useAtom(catalogTableColumnOrderAtom);

  // Track table state changes and add to history
  useEffect(() => {
    // Skip if all values are empty (initial state)
    if (tableSorting.length === 0 && tableFilters.length === 0 && tableColumnOrder.length === 0) {
      return;
    }

    const snapshot = createTableSnapshot(tableId, tableSorting, tableFilters, tableColumnOrder);
    
    // Don't add if it's the same as the last snapshot
    const lastSnapshot = tableHistory.undoStack[tableHistory.undoStack.length - 1];
    if (lastSnapshot && 
        JSON.stringify(lastSnapshot.sorting) === JSON.stringify(snapshot.sorting) &&
        JSON.stringify(lastSnapshot.filters) === JSON.stringify(snapshot.filters) &&
        JSON.stringify(lastSnapshot.columnOrder) === JSON.stringify(snapshot.columnOrder)) {
      return;
    }
    
    console.log("Adding snapshot to history:", snapshot);
    
    // Add to undo stack and clear redo stack
    const newUndoStack = [...tableHistory.undoStack, snapshot];
    
    // Limit history size
    const trimmedUndoStack = newUndoStack.length > tableHistory.maxHistorySize
      ? newUndoStack.slice(-tableHistory.maxHistorySize)
      : newUndoStack;
    
    setTableHistory({
      ...tableHistory,
      undoStack: trimmedUndoStack,
      redoStack: [], // Clear redo stack on new action
    });
  }, [tableSorting, tableFilters, tableColumnOrder, tableId, tableHistory, setTableHistory]);

  const handleUndo = () => {
    if (!canUndo) return;

    setStatus({ isWorking: true, message: "Undoing table change..." });

    const lastSnapshot = tableHistory.undoStack[tableHistory.undoStack.length - 1];
    if (!lastSnapshot || lastSnapshot.tableId !== tableId) {
      setStatus({ isWorking: false, message: "No valid undo state found" });
      setTimeout(() => setStatus({ isWorking: false, message: "" }), 2000);
      return;
    }

    // Create current state snapshot for redo stack BEFORE applying changes
    const currentSnapshot = createTableSnapshot(tableId, tableSorting, tableFilters, tableColumnOrder);

    // Update history stacks
    const newUndoStack = tableHistory.undoStack.slice(0, -1);
    const newRedoStack = [...tableHistory.redoStack, currentSnapshot];

    // Apply previous state IMMEDIATELY
    setTableSorting(lastSnapshot.sorting);
    setTableFilters(lastSnapshot.filters);
    setTableColumnOrder(lastSnapshot.columnOrder);

    // Update history AFTER state changes
    setTableHistory({
      ...tableHistory,
      undoStack: newUndoStack,
      redoStack: newRedoStack,
    });

    setTimeout(() => {
      setStatus({ isWorking: false, message: "Table change undone!" });
      setTimeout(() => {
        setStatus({ isWorking: false, message: "" });
      }, 1500);
    }, 500);
  };

  const handleRedo = () => {
    if (!canRedo) return;

    setStatus({ isWorking: true, message: "Redoing table change..." });

    const nextSnapshot = tableHistory.redoStack[tableHistory.redoStack.length - 1];
    if (!nextSnapshot || nextSnapshot.tableId !== tableId) {
      setStatus({ isWorking: false, message: "No valid redo state found" });
      setTimeout(() => setStatus({ isWorking: false, message: "" }), 2000);
      return;
    }

    // Create current state snapshot for undo stack BEFORE applying changes
    const currentSnapshot = createTableSnapshot(tableId, tableSorting, tableFilters, tableColumnOrder);

    // Update history stacks
    const newRedoStack = tableHistory.redoStack.slice(0, -1);
    const newUndoStack = [...tableHistory.undoStack, currentSnapshot];

    // Apply next state IMMEDIATELY
    setTableSorting(nextSnapshot.sorting);
    setTableFilters(nextSnapshot.filters);
    setTableColumnOrder(nextSnapshot.columnOrder);

    // Update history AFTER state changes
    setTableHistory({
      ...tableHistory,
      undoStack: newUndoStack,
      redoStack: newRedoStack,
    });

    setTimeout(() => {
      setStatus({ isWorking: false, message: "Table change redone!" });
      setTimeout(() => {
        setStatus({ isWorking: false, message: "" });
      }, 1500);
    }, 500);
  };

  const handleReset = () => {
    // Check if there are any table settings to reset
    const hasSettings = 
      tableSorting.length > 0 || 
      tableFilters.length > 0 || 
      tableColumnOrder.length > 0;

    if (!hasSettings) {
      setStatus({ isWorking: false, message: "No table settings to reset" });
      setTimeout(() => setStatus({ isWorking: false, message: "" }), 2000);
      return;
    }

    setStatus({ isWorking: true, message: "Resetting table settings..." });

    console.log("Reset clicked. Creating snapshot before reset...");

    // Create snapshot before reset for undo - THIS IS CRITICAL!
    const currentSnapshot = createTableSnapshot(tableId, tableSorting, tableFilters, tableColumnOrder);
    
    console.log("Snapshot before reset:", currentSnapshot);
    
    // Add to undo stack manually
    const newUndoStack = [...tableHistory.undoStack, currentSnapshot];
    const trimmedUndoStack = newUndoStack.length > tableHistory.maxHistorySize
      ? newUndoStack.slice(-tableHistory.maxHistorySize)
      : newUndoStack;
    
    setTableHistory({
      ...tableHistory,
      undoStack: trimmedUndoStack,
      redoStack: [], // Clear redo stack
    });

    // Clear all table settings AFTER adding to history
    setTableSorting([]);
    setTableFilters([]);
    setTableColumnOrder([]);

    setTimeout(() => {
      setStatus({ isWorking: false, message: "Table settings reset!" });
      setTimeout(() => {
        setStatus({ isWorking: false, message: "" });
      }, 1500);
    }, 500);
  };

  return (
    <div className="flex items-start justify-start gap-1 sm:gap-2 lg:gap-3 flex-wrap">
      <button
        onClick={handleUndo}
        disabled={!canUndo}
        title="Undo Table Change"
        className="flex items-center justify-center p-2 sm:p-2.5 bg-slate-300 text-slate-700 rounded-md hover:bg-slate-400 disabled:bg-gray-200 disabled:text-gray-400 disabled:cursor-not-allowed transition-colors"
      >
        <Undo className="w-3 h-3 sm:w-3.5 sm:h-3.5" />
      </button>

      <button
        onClick={handleRedo}
        disabled={!canRedo}
        title="Redo Table Change"
        className="flex items-center justify-center p-2 sm:p-2.5 bg-slate-300 text-slate-700 rounded-md hover:bg-slate-400 disabled:bg-gray-200 disabled:text-gray-400 disabled:cursor-not-allowed transition-colors"
      >
        <Redo className="w-3 h-3 sm:w-3.5 sm:h-3.5" />
      </button>

      {/* Divider */}
      <div className="w-2 sm:w-4 lg:w-6"></div>

      <button
        onClick={handleReset}
        title="Reset Table Settings"
        className="flex items-center justify-center p-2 sm:p-2.5 bg-slate-300 text-slate-700 rounded-md hover:bg-slate-400 transition-colors"
        aria-label="Reset Table Settings"
      >
        <Settings className="w-3 h-3 sm:w-3.5 sm:h-3.5" />
      </button>
    </div>
  );
};

export default CatalogActions;