import React, { useState, useRef, useEffect } from "react";
import {
  Undo,
  Redo,
  Download,
  Upload,
  RotateCcw,
  Grid2x2Plus,
  Code,
  FileSpreadsheet,
  FileText,
  DollarSign,
  UserPlus,
  Columns3Cog,
} from "lucide-react";
import { useAtom } from "jotai";
import { atomWithStorage } from "jotai/utils";
import {
  setStatusAtom,
  canUndoAtom,
  canRedoAtom,
  undoAtom,
  redoAtom,
  exportPlanAtom,
  createNewPlanAtom,
  resetPlanSelectionsAtom,
  importPlanAtom,
  planStateAtom,
  plannerCoursesAtom,
  addTeamMemberAtom,
} from "@/atoms/globalAtoms";
import {
  tableHistoryStateAtom,
  canUndoTableAtom,
  canRedoTableAtom,
  createTableSnapshot,
} from "@/atoms/table/tableHistoryAtom";
import { ExportModal } from "./common/modals/ExportModal";
import {
  ConfirmationModal,
  useConfirmationModal,
} from "./common/modals/ConfirmationModal";
import { ErrorModal } from "./common/modals/ErrorModal";
import {
  parseImportFile,
  validateCompleteImport,
  hasNonDefaultPlanState,
  filterMissingCourses,
} from "@/utils/planner/importExport";

// Export MonoTable atoms for MonoTable to use - using camelCase naming (like CatalogActions)
export const monoTableSortingAtom = atomWithStorage("monoTableSorting", []);
export const monoTableFiltersAtom = atomWithStorage("monoTableFilters", []);
export const monoTableColumnOrderAtom = atomWithStorage("monoTableColumnOrder", []);

const PlanActions = () => {
  const [showExportModal, setShowExportModal] = useState(false);
  const [showErrorModal, setShowErrorModal] = useState(false);
  const [errorTitle, setErrorTitle] = useState("");
  const [errorMessage, setErrorMessage] = useState("");
  const [errorDetails, setErrorDetails] = useState<string[]>([]);
  const [pendingImport, setPendingImport] = useState<any>(null);

  const fileInputRef = useRef<HTMLInputElement>(null);

  // Plan action atoms
  const [, setStatus] = useAtom(setStatusAtom);
  const [canUndo] = useAtom(canUndoAtom);
  const [canRedo] = useAtom(canRedoAtom);
  const [, undo] = useAtom(undoAtom);
  const [, redo] = useAtom(redoAtom);
  const [, exportPlan] = useAtom(exportPlanAtom);
  const [, createNewPlan] = useAtom(createNewPlanAtom);
  const [, resetSelections] = useAtom(resetPlanSelectionsAtom);
  const [, importPlan] = useAtom(importPlanAtom);
  const [currentPlanState] = useAtom(planStateAtom);
  const [availableCourses] = useAtom(plannerCoursesAtom);
  const [, addTeamMember] = useAtom(addTeamMemberAtom);

  // Table history atoms (like CatalogActions)
  const [canUndoTable] = useAtom(canUndoTableAtom);
  const [canRedoTable] = useAtom(canRedoTableAtom);
  const [tableHistory, setTableHistory] = useAtom(tableHistoryStateAtom);
  const [tableSorting, setTableSorting] = useAtom(monoTableSortingAtom);
  const [tableFilters, setTableFilters] = useAtom(monoTableFiltersAtom);
  const [tableColumnOrder, setTableColumnOrder] = useAtom(monoTableColumnOrderAtom);

  // Flag to prevent useEffect during undo/redo (like CatalogActions)
  const [isUpdatingFromHistory, setIsUpdatingFromHistory] = useState(false);

  const tableId = "mono";

  const {
    showConfirmation,
    showConfirmationModal,
    handleConfirmAction,
    handleCancelAction,
    confirmationTitle,
    confirmationMessage,
  } = useConfirmationModal();

  // Track table state changes and add to history (copied from CatalogActions)
  useEffect(() => {
    // Skip if we're updating from history (undo/redo)
    if (isUpdatingFromHistory) {
      console.log("Skipping history tracking - updating from undo/redo");
      return;
    }

    // Skip if all values are empty (initial state)
    if (
      tableSorting.length === 0 &&
      tableFilters.length === 0 &&
      tableColumnOrder.length === 0
    ) {
      return;
    }

    const snapshot = createTableSnapshot(
      tableId,
      tableSorting,
      tableFilters,
      tableColumnOrder,
    );

    // Don't add if it's the same as the last snapshot
    const lastSnapshot = tableHistory.undoStack[tableHistory.undoStack.length - 1];
    if (
      lastSnapshot &&
      JSON.stringify(lastSnapshot.sorting) === JSON.stringify(snapshot.sorting) &&
      JSON.stringify(lastSnapshot.filters) === JSON.stringify(snapshot.filters) &&
      JSON.stringify(lastSnapshot.columnOrder) === JSON.stringify(snapshot.columnOrder)
    ) {
      return;
    }

    console.log("Adding mono table snapshot to history:", snapshot);

    // Add to undo stack and clear redo stack
    const newUndoStack = [...tableHistory.undoStack, snapshot];

    // Limit history size
    const trimmedUndoStack =
      newUndoStack.length > tableHistory.maxHistorySize
        ? newUndoStack.slice(-tableHistory.maxHistorySize)
        : newUndoStack;

    setTableHistory({
      ...tableHistory,
      undoStack: trimmedUndoStack,
      redoStack: [], // Clear redo stack on new action
    });
  }, [
    tableSorting,
    tableFilters,
    tableColumnOrder,
    tableId,
    tableHistory,
    setTableHistory,
    isUpdatingFromHistory,
  ]);

  // Table undo handler (copied from CatalogActions)
  const handleTableUndo = () => {
    if (!canUndoTable) return;

    setStatus({ isWorking: true, message: "Undoing table change..." });

    const lastSnapshot = tableHistory.undoStack[tableHistory.undoStack.length - 1];
    if (!lastSnapshot || lastSnapshot.tableId !== tableId) {
      setStatus({ isWorking: false, message: "No valid undo state found" });
      setTimeout(() => setStatus({ isWorking: false, message: "" }), 2000);
      return;
    }

    // Create current state snapshot for redo stack BEFORE applying changes
    const currentSnapshot = createTableSnapshot(
      tableId,
      tableSorting,
      tableFilters,
      tableColumnOrder,
    );

    // Update history stacks
    const newUndoStack = tableHistory.undoStack.slice(0, -1);
    const newRedoStack = [...tableHistory.redoStack, currentSnapshot];

    // Apply previous state IMMEDIATELY
    setTableSorting(lastSnapshot.sorting);
    setTableFilters(lastSnapshot.filters);
    setTableColumnOrder(lastSnapshot.columnOrder);

    // Update history AFTER state changes
    setTableHistory({
      ...tableHistory,
      undoStack: newUndoStack,
      redoStack: newRedoStack,
    });

    setTimeout(() => {
      setStatus({ isWorking: false, message: "Table change undone!" });
      setTimeout(() => {
        setStatus({ isWorking: false, message: "" });
      }, 1500);
    }, 500);
  };

  // Table redo handler (copied from CatalogActions)
  const handleTableRedo = () => {
    if (!canRedoTable) return;

    setStatus({ isWorking: true, message: "Redoing table change..." });

    const nextSnapshot = tableHistory.redoStack[tableHistory.redoStack.length - 1];
    if (!nextSnapshot || nextSnapshot.tableId !== tableId) {
      setStatus({ isWorking: false, message: "No valid redo state found" });
      setTimeout(() => setStatus({ isWorking: false, message: "" }), 2000);
      return;
    }

    // Create current state snapshot for undo stack BEFORE applying changes
    const currentSnapshot = createTableSnapshot(
      tableId,
      tableSorting,
      tableFilters,
      tableColumnOrder,
    );

    // Update history stacks
    const newRedoStack = tableHistory.redoStack.slice(0, -1);
    const newUndoStack = [...tableHistory.undoStack, currentSnapshot];

    // Apply next state IMMEDIATELY
    setTableSorting(nextSnapshot.sorting);
    setTableFilters(nextSnapshot.filters);
    setTableColumnOrder(nextSnapshot.columnOrder);

    // Update history AFTER state changes
    setTableHistory({
      ...tableHistory,
      undoStack: newUndoStack,
      redoStack: newRedoStack,
    });

    setTimeout(() => {
      setStatus({ isWorking: false, message: "Table change redone!" });
      setTimeout(() => {
        setStatus({ isWorking: false, message: "" });
      }, 1500);
    }, 500);
  };

  // FIXED: Combined undo/redo logic - works for BOTH plan and table actions
  const canUndoAny = canUndo || canUndoTable;
  const canRedoAny = canRedo || canRedoTable;

  const handleUndoAny = () => {
    // Prioritize plan actions, fall back to table actions
    if (canUndo) {
      undo();
    } else if (canUndoTable) {
      handleTableUndo();
    }
  };

  const handleRedoAny = () => {
    // Prioritize plan actions, fall back to table actions  
    if (canRedo) {
      redo();
    } else if (canRedoTable) {
      handleTableRedo();
    }
  };
  const handleTableReset = () => {
    // Check if there are any table settings to reset
    const hasSettings =
      tableSorting.length > 0 ||
      tableFilters.length > 0 ||
      tableColumnOrder.length > 0;

    if (!hasSettings) {
      setStatus({ isWorking: false, message: "No table settings to reset" });
      setTimeout(() => setStatus({ isWorking: false, message: "" }), 2000);
      return;
    }

    setStatus({ isWorking: true, message: "Resetting table settings..." });

    console.log("Reset clicked. Creating snapshot before reset...");

    // Create snapshot before reset for undo - THIS IS CRITICAL!
    const currentSnapshot = createTableSnapshot(
      tableId,
      tableSorting,
      tableFilters,
      tableColumnOrder,
    );

    console.log("Snapshot before reset:", currentSnapshot);

    // Add to undo stack manually
    const newUndoStack = [...tableHistory.undoStack, currentSnapshot];
    const trimmedUndoStack =
      newUndoStack.length > tableHistory.maxHistorySize
        ? newUndoStack.slice(-tableHistory.maxHistorySize)
        : newUndoStack;

    setTableHistory({
      ...tableHistory,
      undoStack: trimmedUndoStack,
      redoStack: [], // Clear redo stack
    });

    // Clear all table settings AFTER adding to history
    setTableSorting([]);
    setTableFilters([]);
    setTableColumnOrder([]);

    setTimeout(() => {
      setStatus({ isWorking: false, message: "Table settings reset!" });
      setTimeout(() => {
        setStatus({ isWorking: false, message: "" });
      }, 1500);
    }, 500);
  };

  // Plan action handlers (existing functionality)
  const handleAddTeamMember = () => {
    const MAX_TEAM_MEMBERS = 20;

    if (currentPlanState.teamMembers.length >= MAX_TEAM_MEMBERS) {
      setStatus({
        isWorking: false,
        message: `Maximum ${MAX_TEAM_MEMBERS} members allowed`,
      });
      setTimeout(() => setStatus({ isWorking: false, message: "" }), 2000);
      return;
    }

    addTeamMember();
  };

  const handleReset = () => {
    if (Object.keys(currentPlanState.selections).length === 0) {
      setStatus({ isWorking: false, message: "No selections to reset" });
      setTimeout(() => setStatus({ isWorking: false, message: "" }), 2000);
      return;
    }

    showConfirmationModal(
      () => resetSelections(),
      "Reset Course Selections",
      "Are you sure you want to clear all course selections? This action cannot be undone.",
    );
  };

  const handleNew = () => {
    if (!hasNonDefaultPlanState(currentPlanState)) {
      createNewPlan();
      return;
    }

    showConfirmationModal(
      () => createNewPlan(),
      "Create New Plan",
      "Are you sure you want to create a new plan? You will lose all current selections and changes.",
    );
  };

  const handleFileSelect = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    event.target.value = "";
    setStatus({ isWorking: true, message: "Validating import file..." });

    try {
      const fileData = await parseImportFile(file);
      const validationResult = validateCompleteImport(fileData, availableCourses);

      if (!validationResult.isValid || !validationResult.plan) {
        setErrorTitle("Import Validation Failed");
        setErrorMessage("The selected file is not a valid EDUTRON plan export.");
        setErrorDetails(validationResult.errors);
        setShowErrorModal(true);
        setStatus({ isWorking: false, message: "" });
        return;
      }

      if (validationResult.missingCourses.length > 0) {
        setErrorTitle("Missing Courses Detected");
        setErrorMessage(
          `${validationResult.missingCourses.length} course(s) from the imported plan are not available in the current catalog. You can proceed with a partial import or cancel.`,
        );
        setErrorDetails(validationResult.missingCourses);
        setPendingImport(validationResult.plan);
        setShowErrorModal(true);
        setStatus({ isWorking: false, message: "" });
        return;
      }

      if (hasNonDefaultPlanState(currentPlanState)) {
        setPendingImport(validationResult.plan);
        showConfirmationModal(
          () => executeImport(validationResult.plan),
          "Import Plan",
          `Import "${validationResult.plan.plan.title}"? This will replace your current plan and all changes will be lost.`,
        );
      } else {
        executeImport(validationResult.plan);
      }

      setStatus({ isWorking: false, message: "" });
    } catch (error) {
      setErrorTitle("Import Failed");
      setErrorMessage(error instanceof Error ? error.message : "Failed to import plan");
      setErrorDetails([]);
      setShowErrorModal(true);
      setStatus({ isWorking: false, message: "" });
    }
  };

  const executeImport = (plan: any) => {
    importPlan(plan.plan);
    setPendingImport(null);
  };

  const handleProceedWithPartialImport = () => {
    if (!pendingImport) return;

    setStatus({
      isWorking: true,
      message: "Importing plan with missing courses filtered...",
    });

    const missingCourses = errorDetails;
    const filteredSelections = filterMissingCourses(
      pendingImport.plan.selections,
      missingCourses,
    );

    const planWithFilteredSelections = {
      ...pendingImport.plan,
      selections: filteredSelections,
    };

    if (hasNonDefaultPlanState(currentPlanState)) {
      showConfirmationModal(
        () => executeImport({ plan: planWithFilteredSelections }),
        "Import Plan",
        `Import "${pendingImport.plan.title}" with missing courses removed? This will replace your current plan and all changes will be lost.`,
      );
    } else {
      executeImport({ plan: planWithFilteredSelections });
    }

    setShowErrorModal(false);
    setPendingImport(null);
    setStatus({ isWorking: false, message: "" });
  };

  const handleUpload = () => {
    fileInputRef.current?.click();
  };

  const handleDownload = () => {
    setShowExportModal(true);
  };

  const handleExportJSON = () => {
    setShowExportModal(false);
    exportPlan();
  };

  const handleExportCSV = () => {
    setStatus({ isWorking: false, message: "Coming soon..." });
    setTimeout(() => setStatus({ isWorking: false, message: "" }), 2000);
  };

  const handleExportPDF = () => {
    setStatus({ isWorking: false, message: "Coming soon..." });
    setTimeout(() => setStatus({ isWorking: false, message: "" }), 2000);
  };

  const handleExportSales = () => {
    setStatus({ isWorking: false, message: "Coming soon..." });
    setTimeout(() => setStatus({ isWorking: false, message: "" }), 2000);
  };

  const renderExportOptions = () => (
    <div className="grid grid-cols-2 gap-4">
      <button
        onClick={handleExportJSON}
        className="flex flex-col items-center justify-center p-6 bg-gradient-to-r from-orange-500 to-pink-500 hover:from-orange-600 hover:to-pink-600 text-white rounded-lg transition-colors font-bold shadow-lg"
        title="Export plan as JSON file (recommended)"
      >
        <Code className="w-8 h-8 mb-2" />
        <span className="text-sm">JSON</span>
        <span className="text-xs opacity-90 mt-1">(Default)</span>
      </button>

      <button
        disabled
        className="flex flex-col items-center justify-center p-6 bg-gray-200 text-gray-400 rounded-lg cursor-not-allowed font-bold"
        title="CSV Export - Coming soon!"
      >
        <FileSpreadsheet className="w-8 h-8 mb-2" />
        <span className="text-sm">CSV</span>
        <span className="text-xs opacity-75 mt-1">Coming soon</span>
      </button>

      <button
        disabled
        className="flex flex-col items-center justify-center p-6 bg-gray-200 text-gray-400 rounded-lg cursor-not-allowed font-bold"
        title="PDF Export - Coming soon!"
      >
        <FileText className="w-8 h-8 mb-2" />
        <span className="text-sm">PDF</span>
        <span className="text-xs opacity-75 mt-1">Coming soon</span>
      </button>

      <button
        disabled
        className="flex flex-col items-center justify-center p-6 bg-gray-200 text-gray-400 rounded-lg cursor-not-allowed font-bold"
        title="Sales Quote - Coming soon!"
      >
        <DollarSign className="w-8 h-8 mb-2" />
        <span className="text-sm">Sales</span>
        <span className="text-xs opacity-75 mt-1">Coming soon</span>
      </button>
    </div>
  );

  return (
    <>
      <div className="flex items-start justify-start gap-1 sm:gap-2 lg:gap-3 flex-wrap">
        {/* Add Team Member */}
        <button
          onClick={handleAddTeamMember}
          disabled={currentPlanState.teamMembers.length >= 20}
          title="Add Team Member"
          className="flex items-center justify-center p-2 sm:p-2.5 bg-slate-300 text-slate-700 rounded-md hover:bg-slate-400 disabled:bg-gray-200 disabled:text-gray-400 disabled:cursor-not-allowed transition-colors"
        >
          <UserPlus className="w-3 h-3 sm:w-3.5 sm:h-3.5" />
        </button>

        <button
          onClick={handleReset}
          title="Reset Plan Selections"
          className="flex items-center justify-center p-2 sm:p-2.5 bg-slate-300 text-slate-700 rounded-md hover:bg-slate-400 transition-colors"
          aria-label="Reset Plan Selections"
        >
          <RotateCcw className="w-3 h-3 sm:w-3.5 sm:h-3.5" />
        </button>

        {/* Divider */}
        <div className="w-2 sm:w-4 lg:w-6"></div>

        {/* FIXED: Now works for BOTH plan and table actions */}
        <button
          onClick={handleUndoAny}
          disabled={!canUndoAny}
          title={canUndo ? "Undo Plan Action" : "Undo Table Change"}
          className="flex items-center justify-center p-2 sm:p-2.5 bg-slate-300 text-slate-700 rounded-md hover:bg-slate-400 disabled:bg-gray-200 disabled:text-gray-400 disabled:cursor-not-allowed transition-colors"
        >
          <Undo className="w-3 h-3 sm:w-3.5 sm:h-3.5" />
        </button>

        <button
          onClick={handleRedoAny}
          disabled={!canRedoAny}
          title={canRedo ? "Redo Plan Action" : "Redo Table Change"}
          className="flex items-center justify-center p-2 sm:p-2.5 bg-slate-300 text-slate-700 rounded-md hover:bg-slate-400 disabled:bg-gray-200 disabled:text-gray-400 disabled:cursor-not-allowed transition-colors"
        >
          <Redo className="w-3 h-3 sm:w-3.5 sm:h-3.5" />
        </button>

        {/* Divider */}
        <div className="w-2 sm:w-4 lg:w-6"></div>

        {/* FIXED: Now works - resets table settings and can be undone */}
        <button
          onClick={handleTableReset}
          title="Reset Table Settings"
          className="flex items-center justify-center p-2 sm:p-2.5 bg-slate-300 text-slate-700 rounded-md hover:bg-slate-400 transition-colors"
          aria-label="Reset Table Settings"
        >
          <Columns3Cog className="w-3 h-3 sm:w-3.5 sm:h-3.5" />
        </button>

        {/* Divider */}
        <div className="w-2 sm:w-4 lg:w-6"></div>

        <button
          onClick={handleDownload}
          title="Download Plan"
          className="flex items-center justify-center p-2 sm:p-2.5 bg-slate-300 text-slate-700 rounded-md hover:bg-slate-400 transition-colors"
        >
          <Download className="w-3 h-3 sm:w-3.5 sm:h-3.5" />
        </button>

        <button
          onClick={handleUpload}
          title="Upload Plan"
          className="flex items-center justify-center p-2 sm:p-2.5 bg-slate-300 text-slate-700 rounded-md hover:bg-slate-400 transition-colors"
        >
          <Upload className="w-3 h-3 sm:w-3.5 sm:h-3.5" />
        </button>

        <button
          onClick={handleNew}
          title="Create New Plan"
          className="flex items-center justify-center p-2 sm:p-2.5 bg-slate-300 text-slate-700 rounded-md hover:bg-slate-400 transition-colors"
        >
          <Grid2x2Plus className="w-3 h-3 sm:w-3.5 sm:h-3.5" />
        </button>
      </div>

      {/* Hidden file input */}
      <input
        ref={fileInputRef}
        type="file"
        accept=".json"
        onChange={handleFileSelect}
        className="hidden"
        id="plan-import-input"
      />

      <ExportModal
        isOpen={showExportModal}
        onClose={() => setShowExportModal(false)}
        title="Export Training Plan"
        description="Choose your preferred export format:"
      >
        {renderExportOptions()}
      </ExportModal>

      <ConfirmationModal
        isOpen={showConfirmation}
        onClose={handleCancelAction}
        onConfirm={handleConfirmAction}
        title={confirmationTitle}
        message={confirmationMessage}
      />

      <ErrorModal
        isOpen={showErrorModal}
        onClose={() => {
          setShowErrorModal(false);
          setPendingImport(null);
        }}
        title={errorTitle}
        message={errorMessage}
        details={errorDetails}
        onProceed={
          errorDetails.length > 0 ? handleProceedWithPartialImport : undefined
        }
        proceedLabel="Import Anyway"
      />
    </>
  );
};

export default PlanActions;