import { atom } from "jotai";
import { PlanAction } from "@/types/actions";
import { planStateAtom, addCourseSelection, removeCourseSelection } from "@/atoms/planner/planStateAtom";
import { isCreditsUnitModeAtom } from "@/atoms/planner/planCalculatorAtom";
import { historyStateAtom, generateActionId } from "@/atoms/history/historyAtom";
import { setStatusAtom } from "@/atoms/ui/workingAtom";

// Action reversal functions
const reverseAction = (action: PlanAction): PlanAction => {
  const baseReverse = {
    timestamp: new Date().toISOString(),
    id: generateActionId(),
  };

  switch (action.type) {
    case "ADD_TEAM_MEMBER":
      return {
        ...baseReverse,
        type: "REMOVE_TEAM_MEMBER",
        payload: {
          member: action.payload.member,
          index: action.payload.index,
          selections: {}, // Will be filled when applied
        },
      };
    
    case "REMOVE_TEAM_MEMBER":
      return {
        ...baseReverse,
        type: "ADD_TEAM_MEMBER",
        payload: {
          member: action.payload.member,
          index: action.payload.index,
        },
      };
    
    case "UPDATE_TEAM_MEMBER":
      return {
        ...baseReverse,
        type: "UPDATE_TEAM_MEMBER",
        payload: {
          index: action.payload.index,
          oldMember: action.payload.newMember,
          newMember: action.payload.oldMember,
        },
      };
    
    case "TOGGLE_COURSE_SELECTION":
      return {
        ...baseReverse,
        type: "TOGGLE_COURSE_SELECTION",
        payload: {
          personId: action.payload.personId,
          catalogId: action.payload.catalogId,
          courseId: action.payload.courseId,
          wasSelected: !action.payload.wasSelected,
        },
      };
    
    case "UPDATE_TITLE":
      return {
        ...baseReverse,
        type: "UPDATE_TITLE",
        payload: {
          oldTitle: action.payload.newTitle,
          newTitle: action.payload.oldTitle,
        },
      };
    
    case "UPDATE_NOTES":
      return {
        ...baseReverse,
        type: "UPDATE_NOTES",
        payload: {
          oldNotes: action.payload.newNotes,
          newNotes: action.payload.oldNotes,
        },
      };
    
    case "SET_BUDGET":
      return {
        ...baseReverse,
        type: "SET_BUDGET",
        payload: {
          oldBudget: action.payload.newBudget,
          newBudget: action.payload.oldBudget,
        },
      };
    
    case "RESET_SELECTIONS":
      return {
        ...baseReverse,
        type: "RESET_SELECTIONS",
        payload: {
          oldSelections: action.payload.oldSelections,
        },
      };
    
    case "IMPORT_PLAN":
      return {
        ...baseReverse,
        type: "IMPORT_PLAN",
        payload: {
          oldPlanState: action.payload.newPlanState,
          newPlanState: action.payload.oldPlanState,
        },
      };
    
    case "TOGGLE_CREDITS_MODE":
      return {
        ...baseReverse,
        type: "TOGGLE_CREDITS_MODE",
        payload: {
          oldMode: action.payload.newMode,
          newMode: action.payload.oldMode,
        },
      };
    
    default:
      throw new Error(`Unknown action type: ${(action as any).type}`);
  }
};

// Apply action without recording to history (for undo/redo)
const applyActionWithoutHistory = (get: any, set: any, action: PlanAction) => {
  const currentState = get(planStateAtom);
  let newState = { ...currentState };
  
  switch (action.type) {
    case "ADD_TEAM_MEMBER":
      newState.teamMembers = [...currentState.teamMembers];
      newState.teamMembers.splice(action.payload.index, 0, action.payload.member);
      break;
    
    case "REMOVE_TEAM_MEMBER":
      newState.teamMembers = currentState.teamMembers.filter((_, i) => i !== action.payload.index);
      const updatedSelections = { ...currentState.selections };
      delete updatedSelections[action.payload.member.id];
      newState.selections = updatedSelections;
      break;
    
    case "UPDATE_TEAM_MEMBER":
      newState.teamMembers = [...currentState.teamMembers];
      newState.teamMembers[action.payload.index] = action.payload.newMember;
      break;
    
    case "TOGGLE_COURSE_SELECTION":
      if (action.payload.wasSelected) {
        newState.selections = removeCourseSelection(
          currentState.selections,
          action.payload.personId,
          action.payload.catalogId,
          action.payload.courseId
        );
      } else {
        newState.selections = addCourseSelection(
          currentState.selections,
          action.payload.personId,
          action.payload.catalogId,
          action.payload.courseId
        );
      }
      break;
    
    case "UPDATE_TITLE":
      newState.title = action.payload.newTitle;
      break;
    
    case "UPDATE_NOTES":
      newState.notes = action.payload.newNotes;
      break;
    
    case "SET_BUDGET":
      newState.budget = action.payload.newBudget;
      break;
    
    case "RESET_SELECTIONS":
      newState.selections = action.payload.oldSelections;
      break;
    
    case "IMPORT_PLAN":
      // SAFETY CHECK: Ensure newPlanState is valid
      if (!action.payload.newPlanState || typeof action.payload.newPlanState !== 'object') {
        console.error("IMPORT_PLAN action has invalid newPlanState in undo/redo:", action.payload.newPlanState);
        set(setStatusAtom, { isWorking: false, message: "Undo/Redo failed: Invalid plan data" });
        return;
      }
      newState = action.payload.newPlanState;
      break;
    
    case "TOGGLE_CREDITS_MODE":
      set(isCreditsUnitModeAtom, action.payload.newMode);
      break;
    
    default:
      console.warn(`Unknown action type: ${(action as any).type}`);
      return;
  }
  
  // SAFETY CHECK: Ensure newState is valid before updating updatedAt
  if (!newState || typeof newState !== 'object') {
    console.error("newState is invalid after undo/redo action processing:", newState);
    set(setStatusAtom, { isWorking: false, message: "Undo/Redo failed: Invalid state" });
    return;
  }
  
  newState.updatedAt = new Date().toISOString();
  set(planStateAtom, newState);
};

// Undo atom
export const undoAtom = atom(
  null,
  (get, set) => {
    const history = get(historyStateAtom);
    
    if (history.undoStack.length === 0) {
      return;
    }
    
    set(setStatusAtom, { isWorking: true, message: "Undoing action..." });
    
    // Get last action from undo stack
    const lastAction = history.undoStack[history.undoStack.length - 1];
    const newUndoStack = history.undoStack.slice(0, -1);
    
    // Create reverse action and add to redo stack
    const reverseActionObj = reverseAction(lastAction);
    const newRedoStack = [...history.redoStack, lastAction];
    
    // Update history
    set(historyStateAtom, {
      ...history,
      undoStack: newUndoStack,
      redoStack: newRedoStack,
    });
    
    // Execute reverse action (without adding to history)
    applyActionWithoutHistory(get, set, reverseActionObj);
    
    setTimeout(() => {
      set(setStatusAtom, { isWorking: false, message: "Action undone!" });
      setTimeout(() => {
        set(setStatusAtom, { isWorking: false, message: "" });
      }, 1500);
    }, 500);
  },
);

// Redo atom
export const redoAtom = atom(
  null,
  (get, set) => {
    const history = get(historyStateAtom);
    
    if (history.redoStack.length === 0) {
      return;
    }
    
    set(setStatusAtom, { isWorking: true, message: "Redoing action..." });
    
    // Get last action from redo stack
    const actionToRedo = history.redoStack[history.redoStack.length - 1];
    const newRedoStack = history.redoStack.slice(0, -1);
    const newUndoStack = [...history.undoStack, actionToRedo];
    
    // Update history
    set(historyStateAtom, {
      ...history,
      undoStack: newUndoStack,
      redoStack: newRedoStack,
    });
    
    // Re-execute the action (without adding to history)
    applyActionWithoutHistory(get, set, actionToRedo);
    
    setTimeout(() => {
      set(setStatusAtom, { isWorking: false, message: "Action redone!" });
      setTimeout(() => {
        set(setStatusAtom, { isWorking: false, message: "" });
      }, 1500);
    }, 500);
  },
);