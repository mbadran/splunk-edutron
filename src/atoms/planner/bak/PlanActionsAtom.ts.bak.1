import { atom } from "jotai";
import { Person, Course, PlanState } from "@/types/types";
import { PlanAction } from "@/types/actions";
import { DEFAULT_PLAN_TITLE, DEFAULT_TEAM_NAMES, DEFAULT_CATALOG } from "@/utils/constants";
import { planStateAtom, hasSelectionForCourse, createInitialPlanState } from "@/atoms/planner/planStateAtom";
import { isCreditsUnitModeAtom } from "@/atoms/planner/planCalculatorAtom";
import { editingTeamMemberAtom, editingTeamMemberValueAtom, isEditingBudgetAtom, budgetInputAtom } from "@/atoms/ui/editingAtom";
import { setStatusAtom } from "@/atoms/ui/workingAtom";
import { scrollTableToTop } from "@/atoms/ui/tableAtom";
import { executeActionAtom } from "@/atoms/history/actionExecutor";
import { generateActionId, addToHistory } from "@/atoms/history/historyAtom";

// Helper to generate random ID with prefix
const generateRandomId = (prefix: string): string => {
  return `${prefix}-${Math.random().toString(36).substr(2, 9)}`;
};

// Helper to check if current plan has any changes (non-default state)
const hasNonDefaultPlanState = (planState: PlanState): boolean => {
  const hasCustomTitle = planState.title !== DEFAULT_PLAN_TITLE;
  const hasCustomNotes = Boolean(planState.notes && planState.notes.trim());
  const hasCustomTeamMembers = planState.teamMembers.length > 1 || 
    (planState.teamMembers.length === 1 && planState.teamMembers[0].name !== DEFAULT_TEAM_NAMES[0]);
  const hasCourseSelections = Object.keys(planState.selections).length > 0;
  const hasBudget = planState.budget !== null;

  return hasCustomTitle || hasCustomNotes || hasCustomTeamMembers || hasCourseSelections || hasBudget;
};

// Budget management action atoms - updated to use history
export const setBudgetAtom = atom(
  null,
  (get, set, budget: number | null) => {
    set(setStatusAtom, { isWorking: true, message: "Updating budget..." });
    
    const currentState = get(planStateAtom);
    
    // Create action
    const action: PlanAction = {
      type: "SET_BUDGET",
      timestamp: new Date().toISOString(),
      id: generateActionId(),
      payload: {
        oldBudget: currentState.budget,
        newBudget: budget,
      },
    };
    
    // Execute action
    set(executeActionAtom, action);
    
    // Clear editing state
    set(isEditingBudgetAtom, false);
    set(budgetInputAtom, "");
    
    set(setStatusAtom, { isWorking: false, message: "" });
  },
);

// Team member management action atoms - updated to use history
export const addTeamMemberAtom = atom(
  null,
  (get, set, newMember: Person) => {
    set(setStatusAtom, { isWorking: true, message: "Adding team member..." });
    
    const currentState = get(planStateAtom);
    const currentTeamId = currentState.teams[0]; // Use first (and currently only) team
    
    const memberWithId = {
      ...newMember,
      id: newMember.id || generateRandomId('person'),
      teamId: currentTeamId,
    };
    
    const action: PlanAction = {
      type: "ADD_TEAM_MEMBER",
      timestamp: new Date().toISOString(),
      id: generateActionId(),
      payload: {
        member: memberWithId,
        index: currentState.teamMembers.length, // Add at end
      },
    };
    
    set(executeActionAtom, action);
  },
);

export const updateTeamMemberAtom = atom(
  null,
  (get, set, { index, updates }: { index: number; updates: Partial<Person> }) => {
    set(setStatusAtom, { isWorking: true, message: "Updating team member..." });
    
    const currentState = get(planStateAtom);
    const oldMember = currentState.teamMembers[index];
    const newMember = { ...oldMember, ...updates };
    
    const action: PlanAction = {
      type: "UPDATE_TEAM_MEMBER",
      timestamp: new Date().toISOString(),
      id: generateActionId(),
      payload: {
        index,
        oldMember,
        newMember,
      },
    };
    
    set(executeActionAtom, action);
    
    // Clear editing state
    set(editingTeamMemberAtom, null);
    set(editingTeamMemberValueAtom, "");
  },
);

export const deleteTeamMemberAtom = atom(
  null,
  (get, set, index: number) => {
    set(setStatusAtom, { isWorking: true, message: "Removing team member..." });
    
    const currentState = get(planStateAtom);
    const memberToDelete = currentState.teamMembers[index];
    
    const action: PlanAction = {
      type: "REMOVE_TEAM_MEMBER",
      timestamp: new Date().toISOString(),
      id: generateActionId(),
      payload: {
        member: memberToDelete,
        index,
        selections: currentState.selections[memberToDelete.id] || {},
      },
    };
    
    set(executeActionAtom, action);
    
    // Clear editing state if needed
    const currentEditing = get(editingTeamMemberAtom);
    if (currentEditing === index) {
      set(editingTeamMemberAtom, null);
      set(editingTeamMemberValueAtom, "");
    } else if (currentEditing !== null && currentEditing > index) {
      set(editingTeamMemberAtom, currentEditing - 1);
    }
  },
);

// Create new plan action atom - updated to use history and check for changes
export const createNewPlanAtom = atom(
  null,
  (get, set) => {
    const currentState = get(planStateAtom);
    
    // Check if current plan has changes
    if (!hasNonDefaultPlanState(currentState)) {
      // No changes, just create new plan without confirmation
      set(setStatusAtom, { isWorking: true, message: "Creating new plan..." });
      
      const newPlanState = createInitialPlanState();
      
      const action: PlanAction = {
        type: "IMPORT_PLAN",
        timestamp: new Date().toISOString(),
        id: generateActionId(),
        payload: {
          oldPlanState: currentState,
          newPlanState,
        },
      };
      
      set(executeActionAtom, action);
      
      // Reset other related state
      set(isEditingBudgetAtom, false);
      set(budgetInputAtom, "");
      set(editingTeamMemberAtom, null);
      set(editingTeamMemberValueAtom, "");
      
      // Scroll table to top
      scrollTableToTop(get, set);
      
      setTimeout(() => {
        set(setStatusAtom, { isWorking: false, message: "New plan created!" });
        setTimeout(() => {
          set(setStatusAtom, { isWorking: false, message: "" });
        }, 1500);
      }, 500);
      
      return;
    }
    
    // Has changes, will need confirmation - this should be handled by the UI component
    set(setStatusAtom, { isWorking: false, message: "Plan has changes - confirmation needed" });
  },
);

// Reset plan selections action atom - updated to use history and check for changes
export const resetPlanSelectionsAtom = atom(
  null,
  (get, set) => {
    const currentState = get(planStateAtom);
    
    // Check if there are any selections to reset
    if (Object.keys(currentState.selections).length === 0) {
      set(setStatusAtom, { isWorking: false, message: "No selections to reset" });
      return;
    }
    
    set(setStatusAtom, { isWorking: true, message: "Clearing course selections..." });
    
    const action: PlanAction = {
      type: "RESET_SELECTIONS",
      timestamp: new Date().toISOString(),
      id: generateActionId(),
      payload: {
        oldSelections: currentState.selections,
      },
    };
    
    set(executeActionAtom, action);
    
    // Scroll table to top
    scrollTableToTop(get, set);
    
    setTimeout(() => {
      set(setStatusAtom, { isWorking: false, message: "Course selections cleared!" });
      setTimeout(() => {
        set(setStatusAtom, { isWorking: false, message: "" });
      }, 1500);
    }, 500);
  },
);

// Import plan action atom - updated to use history
export const importPlanAtom = atom(
  null,
  (get, set, importedPlanState: PlanState) => {
    set(setStatusAtom, { isWorking: true, message: "Importing plan..." });
    
    const currentState = get(planStateAtom);
    
    const action: PlanAction = {
      type: "IMPORT_PLAN",
      timestamp: new Date().toISOString(),
      id: generateActionId(),
      payload: {
        oldPlanState: currentState,
        newPlanState: importedPlanState,
      },
    };
    
    set(executeActionAtom, action);
    
    // Reset other related state
    set(isEditingBudgetAtom, false);
    set(budgetInputAtom, "");
    set(editingTeamMemberAtom, null);
    set(editingTeamMemberValueAtom, "");
    
    // Scroll table to top
    scrollTableToTop(get, set);
    
    setTimeout(() => {
      set(setStatusAtom, { isWorking: false, message: "Plan imported successfully!" });
      setTimeout(() => {
        set(setStatusAtom, { isWorking: false, message: "" });
      }, 2000);
    }, 500);
  },
);

// Update title action atom - new
export const updateTitleAtom = atom(
  null,
  (get, set, newTitle: string) => {
    const currentState = get(planStateAtom);
    
    if (currentState.title === newTitle) {
      return; // No change
    }
    
    const action: PlanAction = {
      type: "UPDATE_TITLE",
      timestamp: new Date().toISOString(),
      id: generateActionId(),
      payload: {
        oldTitle: currentState.title,
        newTitle,
      },
    };
    
    set(executeActionAtom, action);
  },
);

// Update notes action atom - new
export const updateNotesAtom = atom(
  null,
  (get, set, newNotes: string) => {
    const currentState = get(planStateAtom);
    const currentNotes = currentState.notes || "";
    
    if (currentNotes === newNotes) {
      return; // No change
    }
    
    const action: PlanAction = {
      type: "UPDATE_NOTES",
      timestamp: new Date().toISOString(),
      id: generateActionId(),
      payload: {
        oldNotes: currentNotes,
        newNotes,
      },
    };
    
    set(executeActionAtom, action);
  },
);

// Toggle credits mode action atom - updated to use history
export const toggleCreditsModeAtom = atom(
  null,
  (get, set) => {
    const currentMode = get(isCreditsUnitModeAtom);
    const newMode = !currentMode;
    
    const action: PlanAction = {
      type: "TOGGLE_CREDITS_MODE",
      timestamp: new Date().toISOString(),
      id: generateActionId(),
      payload: {
        oldMode: currentMode,
        newMode,
      },
    };
    
    // For credits mode, just update the atom directly since it's not part of plan state
    set(isCreditsUnitModeAtom, newMode);
    
    // Still add to history for undo/redo
    addToHistory(get, set, action);
  },
);

// Selection management action atom - updated to use history
export const toggleSelectionAtom = atom(
  null,
  (get, set, { course, member }: { course: Course; member: Person }) => {
    const currentState = get(planStateAtom);
    const catalogId = DEFAULT_CATALOG; // For now, use default catalog
    
    const wasSelected = hasSelectionForCourse(currentState.selections, member.id, catalogId, course.ID);
    
    const action: PlanAction = {
      type: "TOGGLE_COURSE_SELECTION",
      timestamp: new Date().toISOString(),
      id: generateActionId(),
      payload: {
        personId: member.id,
        catalogId,
        courseId: course.ID,
        wasSelected,
      },
    };
    
    set(executeActionAtom, action);
  },
);